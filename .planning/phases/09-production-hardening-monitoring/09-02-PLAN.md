---
phase: 09-production-hardening-monitoring
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - app/services/monitoring/circuit_breakers.py
  - app/config.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Circuit breaker opens after 5 consecutive failures"
    - "Circuit breaker auto-recovers after 60 seconds"
    - "Admin receives email notification when circuit breaker opens"
  artifacts:
    - path: "app/services/monitoring/circuit_breakers.py"
      provides: "Circuit breaker instances for external services"
      contains: "claude_breaker"
    - path: "app/services/monitoring/circuit_breakers.py"
      provides: "Email notification listener"
      contains: "CircuitBreakerEmailListener"
  key_links:
    - from: "app/services/monitoring/circuit_breakers.py"
      to: "pybreaker"
      via: "CircuitBreaker import"
      pattern: "import pybreaker"
    - from: "app/services/monitoring/circuit_breakers.py"
      to: "app/services/email_notifier.py"
      via: "email notification"
      pattern: "send_alert|send_circuit_breaker"
---

<objective>
Implement circuit breakers for external service dependencies (Claude API, MongoDB, GCS) with email alerts when circuits open.

Purpose: Circuit breakers prevent cascading failures when external services are unavailable, automatically stopping requests to failing services and notifying admins for investigation.

Output: Three circuit breaker instances with configurable thresholds and email notification on state changes.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-production-hardening-monitoring/09-CONTEXT.md
@.planning/phases/09-production-hardening-monitoring/09-RESEARCH.md

# Existing patterns to follow
@app/services/email_notifier.py
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pybreaker dependency and circuit breaker config settings</name>
  <files>
    requirements.txt
    app/config.py
  </files>
  <action>
    1. Add to requirements.txt:
       - pybreaker>=1.4.1

    2. Update app/config.py Settings class to add circuit breaker configuration:
       - circuit_breaker_fail_max: int = 5  # USER DECISION: 5 consecutive failures
       - circuit_breaker_reset_timeout: int = 60  # USER DECISION: 60 seconds auto-recovery
       - circuit_breaker_alert_email: Optional[str] = None  # Falls back to admin_email

    These settings make circuit breaker behavior configurable via environment variables:
    CIRCUIT_BREAKER_FAIL_MAX, CIRCUIT_BREAKER_RESET_TIMEOUT, CIRCUIT_BREAKER_ALERT_EMAIL
  </action>
  <verify>
    pip install pybreaker>=1.4.1 && python -c "import pybreaker; from app.config import settings; print(f'fail_max={settings.circuit_breaker_fail_max}')"
  </verify>
  <done>
    pybreaker added to requirements.txt.
    Circuit breaker settings added to Settings class with USER DECISION defaults.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create circuit breakers with email notification listener</name>
  <files>
    app/services/monitoring/circuit_breakers.py
    app/services/monitoring/__init__.py
  </files>
  <action>
    1. Create app/services/monitoring/circuit_breakers.py:

       a. Import pybreaker, logging, smtplib, email.mime modules
       b. Import settings from app.config

       c. Create CircuitBreakerEmailListener(pybreaker.CircuitBreakerListener):
          - __init__ takes admin_email parameter
          - state_change(cb, old_state, new_state) method:
            - If new_state == pybreaker.STATE_OPEN, send email alert
            - Log the state change at WARNING level
            - Email subject: "ALERT: Circuit Breaker Opened - {cb.name}"
            - Email body: Service name, failure count, recovery timeout, investigation request
            - Use SMTP settings from app.config.settings (smtp_host, smtp_port, etc.)
            - Catch and log email failures - don't crash on notification failure

       d. Create _create_breaker(name: str, listener: CircuitBreakerEmailListener) helper:
          - Returns pybreaker.CircuitBreaker with:
            - name=name
            - fail_max=settings.circuit_breaker_fail_max
            - reset_timeout=settings.circuit_breaker_reset_timeout
            - listeners=[listener]

       e. Create module-level instances (lazy initialization pattern):
          - _email_listener = None
          - _claude_breaker = None
          - _mongodb_breaker = None
          - _gcs_breaker = None

       f. Create get_breaker(service_name: str) function:
          - Lazy initializes _email_listener with admin_email from settings
          - Returns appropriate breaker based on service_name: "claude", "mongodb", "gcs"
          - Creates breaker on first access

       g. Export breaker access functions:
          - get_claude_breaker() -> pybreaker.CircuitBreaker
          - get_mongodb_breaker() -> pybreaker.CircuitBreaker
          - get_gcs_breaker() -> pybreaker.CircuitBreaker

    2. Update app/services/monitoring/__init__.py:
       - Add exports: get_claude_breaker, get_mongodb_breaker, get_gcs_breaker, CircuitBreakerEmailListener

    Use pattern from 09-RESEARCH.md "Circuit Breaker with Email Alerts" code example.
    Use lazy initialization to avoid import-time SMTP connections.
  </action>
  <verify>
    python -c "from app.services.monitoring.circuit_breakers import get_claude_breaker, get_mongodb_breaker, get_gcs_breaker; cb = get_claude_breaker(); print(f'Claude breaker: {cb.name}, fail_max={cb.fail_max}')"
  </verify>
  <done>
    CircuitBreakerEmailListener sends email on STATE_OPEN.
    Three circuit breakers created: claude_api, mongodb, google_cloud_storage.
    Breakers use configurable thresholds from settings.
    Lazy initialization prevents import-time side effects.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create circuit breaker decorator for easy service wrapping</name>
  <files>
    app/services/monitoring/circuit_breakers.py
  </files>
  <action>
    Add to app/services/monitoring/circuit_breakers.py:

    1. Create with_circuit_breaker(service_name: str) decorator:
       ```python
       def with_circuit_breaker(service_name: str):
           """Decorator to wrap function with circuit breaker protection."""
           def decorator(func):
               @functools.wraps(func)
               def wrapper(*args, **kwargs):
                   breaker = get_breaker(service_name)
                   return breaker.call(func, *args, **kwargs)
               return wrapper
           return decorator
       ```

    2. Create CircuitBreakerOpen exception re-export for caller handling:
       from pybreaker import CircuitBreakerError

    3. Add to exports in __init__.py:
       - with_circuit_breaker
       - CircuitBreakerError (from pybreaker)

    Usage example (for documentation in docstring):
    ```python
    @with_circuit_breaker("claude")
    def call_claude_api(payload):
        # API call here
        pass
    ```

    This decorator will be applied to external service calls in the integration plan.
    For now, just create the decorator - integration happens in 09-05.
  </action>
  <verify>
    python -c "from app.services.monitoring.circuit_breakers import with_circuit_breaker, CircuitBreakerError; print('Decorator and exception imported successfully')"
  </verify>
  <done>
    with_circuit_breaker decorator created for easy service wrapping.
    CircuitBreakerError re-exported for caller exception handling.
  </done>
</task>

</tasks>

<verification>
1. Import test: `python -c "from app.services.monitoring import get_claude_breaker, get_mongodb_breaker, get_gcs_breaker, with_circuit_breaker"`
2. Config test: `python -c "from app.config import settings; print(f'Circuit breaker: {settings.circuit_breaker_fail_max} failures, {settings.circuit_breaker_reset_timeout}s timeout')"`
3. Breaker behavior test:
   ```python
   from app.services.monitoring.circuit_breakers import get_claude_breaker
   cb = get_claude_breaker()
   # Simulate failures
   for _ in range(5):
       try:
           cb.call(lambda: 1/0)
       except:
           pass
   print(f"State after 5 failures: {cb.state}")  # Should be STATE_OPEN
   ```
</verification>

<success_criteria>
- pybreaker>=1.4.1 added to requirements.txt
- Circuit breaker settings in app/config.py with USER DECISION defaults (5 failures, 60s timeout)
- CircuitBreakerEmailListener sends alert email when circuit opens
- Three breakers created: claude_api, mongodb, google_cloud_storage
- with_circuit_breaker decorator available for service wrapping
- Lazy initialization prevents import-time side effects
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening-monitoring/09-02-SUMMARY.md`
</output>
