---
phase: 09-production-hardening-monitoring
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/monitoring/__init__.py
  - app/services/monitoring/logging.py
  - app/middleware/__init__.py
  - app/middleware/correlation_id.py
  - app/main.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "All log entries include correlation_id field"
    - "Logs are JSON formatted and machine-parseable"
    - "Correlation ID propagates from webhook through actor processing"
  artifacts:
    - path: "app/services/monitoring/logging.py"
      provides: "JSON formatter with correlation ID injection"
      contains: "CorrelationJsonFormatter"
    - path: "app/middleware/correlation_id.py"
      provides: "ASGI middleware for correlation ID"
      contains: "CorrelationIdMiddleware"
  key_links:
    - from: "app/main.py"
      to: "app/middleware/correlation_id.py"
      via: "app.add_middleware"
      pattern: "add_middleware.*CorrelationIdMiddleware"
    - from: "app/services/monitoring/logging.py"
      to: "asgi_correlation_id"
      via: "context import"
      pattern: "from asgi_correlation_id.context import correlation_id"
---

<objective>
Establish structured JSON logging with correlation ID propagation for request tracing across the async email processing pipeline.

Purpose: Correlation IDs enable end-to-end request tracing from webhook receipt through Dramatiq actor processing to final database write, critical for debugging production issues.

Output: JSON logging infrastructure with automatic correlation ID injection into all log entries.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-production-hardening-monitoring/09-CONTEXT.md
@.planning/phases/09-production-hardening-monitoring/09-RESEARCH.md

# Existing patterns to follow
@app/main.py
@app/config.py
@app/actors/email_processor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logging infrastructure with JSON formatter and correlation ID</name>
  <files>
    app/services/monitoring/__init__.py
    app/services/monitoring/logging.py
    requirements.txt
  </files>
  <action>
    1. Add to requirements.txt:
       - python-json-logger>=2.0.7
       - asgi-correlation-id>=4.0.0

    2. Create app/services/monitoring/__init__.py with exports for setup_logging

    3. Create app/services/monitoring/logging.py:
       - Import pythonjsonlogger.jsonlogger and asgi_correlation_id.context
       - Create CorrelationJsonFormatter(jsonlogger.JsonFormatter) that:
         - Overrides add_fields() to inject correlation_id from correlation_id.get() or 'none'
         - Adds service='creditor-answer-analysis' field
         - Adds environment from os.getenv('ENVIRONMENT', 'development')
       - Create setup_logging() function that:
         - Creates StreamHandler(sys.stdout)
         - Sets CorrelationJsonFormatter with timestamp and level fields
         - Configures root logger with INFO level (USER DECISION)
         - Returns the handler for testing

    Use pattern from 09-RESEARCH.md "Complete Logging Setup" code example.
    Do NOT use structlog - replace existing structlog usage with standard logging + python-json-logger.
  </action>
  <verify>
    python -c "from app.services.monitoring.logging import setup_logging, CorrelationJsonFormatter; print('Logging module imports successfully')"
  </verify>
  <done>
    CorrelationJsonFormatter exists and injects correlation_id into log records.
    setup_logging() configures JSON logging to stdout with INFO level.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create correlation ID middleware and integrate into FastAPI app</name>
  <files>
    app/middleware/__init__.py
    app/middleware/correlation_id.py
    app/main.py
  </files>
  <action>
    1. Create app/middleware/__init__.py with exports

    2. Create app/middleware/correlation_id.py:
       - Import CorrelationIdMiddleware from asgi_correlation_id
       - Re-export for convenience: from asgi_correlation_id import CorrelationIdMiddleware
       - Add helper function get_correlation_id() that returns correlation_id.get() or 'none'
       - This helper is used by Dramatiq actors to manually propagate correlation ID

    3. Update app/main.py:
       - Import CorrelationIdMiddleware from app.middleware.correlation_id
       - Import setup_logging from app.services.monitoring.logging
       - Add app.add_middleware(CorrelationIdMiddleware) BEFORE router registration
       - Call setup_logging() at module level (before app creation)
       - Remove existing structlog.configure() block (replaced by setup_logging)
       - Keep structlog.get_logger() calls - they will be replaced in integration plan

    Middleware order matters: CorrelationIdMiddleware must be added before routes so correlation_id context is available during request handling.
  </action>
  <verify>
    python -c "from app.main import app; print('App with middleware imports successfully')"
    curl -s http://localhost:8000/health 2>/dev/null | python -m json.tool || echo "Server not running - import test passed"
  </verify>
  <done>
    CorrelationIdMiddleware added to FastAPI app.
    setup_logging() called at startup.
    All HTTP requests have correlation ID in context.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add correlation ID propagation to Dramatiq actors</name>
  <files>
    app/actors/email_processor.py
  </files>
  <action>
    1. Update app/actors/email_processor.py:
       - Import: from asgi_correlation_id.context import correlation_id as correlation_id_ctx
       - Import: import logging (standard library)
       - Replace structlog.get_logger() with logging.getLogger(__name__)

    2. Modify process_email actor signature to accept optional correlation_id parameter:
       def process_email(email_id: int, correlation_id: str = None) -> None:

    3. At the START of process_email():
       - If correlation_id parameter provided, set it: correlation_id_ctx.set(correlation_id)
       - This re-establishes correlation context lost when Dramatiq actor runs in separate thread

    4. Update all logger.info/error/warning calls to use standard logging pattern:
       - logger.info("message", extra={"email_id": email_id, ...})
       - The CorrelationJsonFormatter will automatically inject correlation_id

    Note: Webhook handler will be updated in integration plan to pass correlation_id when enqueueing.
    For now, correlation_id parameter defaults to None for backward compatibility.
  </action>
  <verify>
    python -c "from app.actors.email_processor import process_email; print('Actor imports with correlation_id parameter')"
  </verify>
  <done>
    process_email actor accepts correlation_id parameter.
    Correlation ID context restored at actor start.
    All logs in actor use standard logging with extra fields.
  </done>
</task>

</tasks>

<verification>
1. Import test: `python -c "from app.services.monitoring.logging import setup_logging; from app.middleware.correlation_id import CorrelationIdMiddleware"`
2. Actor test: `python -c "from app.actors.email_processor import process_email; import inspect; sig = inspect.signature(process_email.fn); print('correlation_id' in sig.parameters)"`
3. Logging format test: Start app, make request, verify JSON logs contain correlation_id field
</verification>

<success_criteria>
- python-json-logger and asgi-correlation-id added to requirements.txt
- CorrelationJsonFormatter injects correlation_id into all log entries
- CorrelationIdMiddleware added to FastAPI app
- process_email actor accepts and propagates correlation_id
- Logs output as JSON with timestamp, level, message, correlation_id fields
</success_criteria>

<output>
After completion, create `.planning/phases/09-production-hardening-monitoring/09-01-SUMMARY.md`
</output>
