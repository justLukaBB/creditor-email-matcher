---
phase: 08-database-backed-prompt-management
plan: 03
type: execute
wave: 3
depends_on: ["08-02"]
files_modified:
  - app/services/intent_classifier.py
  - app/services/entity_extractor_claude.py
  - app/services/extraction/pdf_extractor.py
  - app/services/extraction/image_extractor.py
autonomous: true

must_haves:
  truths:
    - "Intent classifier loads prompt from database if active version exists"
    - "Entity extractor loads system/user prompts from database"
    - "PDF extractor loads EXTRACTION_PROMPT from database for scanned PDFs"
    - "Image extractor loads IMAGE_EXTRACTION_PROMPT from database"
    - "All extractors log prompt_template_id and record metrics"
  artifacts:
    - path: "app/services/intent_classifier.py"
      provides: "Database-backed intent classification prompt"
      contains: "get_active_prompt"
    - path: "app/services/entity_extractor_claude.py"
      provides: "Database-backed entity extraction prompts"
      contains: "get_active_prompt"
    - path: "app/services/extraction/pdf_extractor.py"
      provides: "Database-backed PDF extraction prompt"
      contains: "get_active_prompt"
    - path: "app/services/extraction/image_extractor.py"
      provides: "Database-backed image extraction prompt"
      contains: "get_active_prompt"
  key_links:
    - from: "app/services/intent_classifier.py"
      to: "app/services/prompt_manager.py"
      via: "get_active_prompt call"
      pattern: "get_active_prompt.*classification.*email_intent"
    - from: "app/services/extraction/pdf_extractor.py"
      to: "app/services/prompt_metrics_service.py"
      via: "record_extraction_metrics call"
      pattern: "record_extraction_metrics"
---

<objective>
Integrate database-backed prompts into all extraction services: intent_classifier, entity_extractor_claude, pdf_extractor, image_extractor. Each service loads active prompt from database, renders with Jinja2, and records metrics with prompt_template_id.

Purpose: Enable runtime prompt updates without redeployment while maintaining audit trail of which prompt version processed each email.
Output: All extraction services use database-backed prompts with metrics tracking.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/08-database-backed-prompt-management/08-CONTEXT.md
@.planning/phases/08-database-backed-prompt-management/08-RESEARCH.md
@.planning/phases/08-database-backed-prompt-management/08-02-SUMMARY.md
@app/services/intent_classifier.py
@app/services/entity_extractor_claude.py
@app/services/extraction/pdf_extractor.py
@app/services/extraction/image_extractor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate database prompts into intent_classifier.py</name>
  <files>app/services/intent_classifier.py</files>
  <action>
Modify classify_intent_with_llm() to use database-backed prompt:

1. Add imports:
```python
from app.services.prompt_manager import get_active_prompt
from app.services.prompt_renderer import PromptRenderer
from app.services.prompt_metrics_service import record_extraction_metrics
```

2. In classify_intent_with_llm(), before constructing prompt:
```python
# Try database-backed prompt first
prompt_template = None
db = None  # Get session from context or create new
try:
    from app.database import SessionLocal
    db = SessionLocal()
    prompt_template = get_active_prompt(db, task_type='classification', name='email_intent')
except Exception as e:
    logger.warning("database_prompt_load_failed", error=str(e))
```

3. If prompt_template exists, use it:
```python
if prompt_template:
    renderer = PromptRenderer()
    prompt = renderer.render(
        prompt_template.user_prompt_template,
        variables={'subject': subject, 'truncated_body': truncated_body},
        template_name='classification.email_intent'
    )
    # Use prompt_template.model_name, temperature, max_tokens
else:
    # Fallback to hardcoded prompt (current behavior)
    prompt = f"""Klassifiziere die E-Mail-Intent..."""
```

4. After API call, record metrics if prompt_template was used:
```python
if prompt_template and db:
    import time
    record_extraction_metrics(
        db=db,
        prompt_template_id=prompt_template.id,
        email_id=email_id,  # Need to pass email_id to function
        input_tokens=response.usage.input_tokens,
        output_tokens=response.usage.output_tokens,
        model_name=prompt_template.model_name,
        extraction_success=True,
        confidence_score=confidence,
        manual_review_required=False,
        execution_time_ms=int((time.time() - start_time) * 1000)
    )
    db.commit()
```

5. Update function signature to accept email_id for metrics:
```python
def classify_intent_with_llm(body: str, subject: str, email_id: int = None) -> IntentResult:
```

6. Ensure db session is closed in finally block.

Preserve current hardcoded prompt as fallback if no active database prompt exists.
  </action>
  <verify>python -c "from app.services.intent_classifier import classify_intent_with_llm; print(classify_intent_with_llm.__doc__)"</verify>
  <done>intent_classifier loads prompt from database, falls back to hardcoded if no active version</done>
</task>

<task type="auto">
  <name>Task 2: Integrate database prompts into entity_extractor_claude.py</name>
  <files>app/services/entity_extractor_claude.py</files>
  <action>
Modify EntityExtractorClaude to use database-backed prompts:

1. Add imports at top:
```python
from app.services.prompt_manager import get_active_prompt
from app.services.prompt_renderer import PromptRenderer
from app.services.prompt_metrics_service import record_extraction_metrics
```

2. Modify extract_entities() to accept email_id and db session:
```python
def extract_entities(
    self,
    email_body: str,
    from_email: str,
    subject: Optional[str] = None,
    email_id: int = None,
    db: "Session" = None
) -> ExtractedEntities:
```

3. Load prompts from database:
```python
system_prompt = None
user_template = None
prompt_template = None

if db:
    prompt_template = get_active_prompt(db, task_type='extraction', name='email_body')
    if prompt_template:
        system_prompt = prompt_template.system_prompt
        renderer = PromptRenderer()
        user_template = renderer.render(
            prompt_template.user_prompt_template,
            variables={
                'from_email': from_email,
                'subject': subject or '',
                'email_body': email_body
            },
            template_name='extraction.email_body'
        )
```

4. Fallback to hardcoded methods if no database prompt:
```python
if not system_prompt:
    system_prompt = self._get_system_prompt()  # existing method
if not user_template:
    user_template = self._build_extraction_prompt(email_body, from_email, subject)  # existing method
```

5. After API call, record metrics:
```python
if prompt_template and db and email_id:
    record_extraction_metrics(
        db=db,
        prompt_template_id=prompt_template.id,
        email_id=email_id,
        input_tokens=message.usage.input_tokens,
        output_tokens=message.usage.output_tokens,
        model_name=prompt_template.model_name or settings.anthropic_model,
        extraction_success=entities.is_creditor_reply,
        confidence_score=entities.confidence,
        manual_review_required=entities.confidence < 0.6,
        execution_time_ms=execution_time_ms
    )
```

Keep existing _get_system_prompt() and _build_extraction_prompt() methods as fallback.
  </action>
  <verify>python -c "from app.services.entity_extractor_claude import EntityExtractorClaude; print(EntityExtractorClaude.extract_entities.__doc__)"</verify>
  <done>EntityExtractorClaude loads system/user prompts from database, records metrics with prompt_template_id</done>
</task>

<task type="auto">
  <name>Task 3: Integrate database prompts into pdf_extractor.py and image_extractor.py</name>
  <files>app/services/extraction/pdf_extractor.py, app/services/extraction/image_extractor.py</files>
  <action>
Modify PDFExtractor._extract_with_claude_vision():

1. Add imports at top of pdf_extractor.py:
```python
from app.services.prompt_manager import get_active_prompt
from app.services.prompt_renderer import PromptRenderer
from app.services.prompt_metrics_service import record_extraction_metrics
```

2. Modify __init__ to accept db session:
```python
def __init__(
    self,
    token_budget: TokenBudgetTracker,
    claude_client: Optional["Anthropic"] = None,
    max_pages: int = 10,
    db: "Session" = None,
    email_id: int = None
):
    ...
    self.db = db
    self.email_id = email_id
```

3. In _extract_with_claude_vision(), load prompt from database:
```python
prompt_text = EXTRACTION_PROMPT  # Hardcoded fallback
prompt_template = None

if self.db:
    prompt_template = get_active_prompt(self.db, task_type='extraction', name='pdf_scanned')
    if prompt_template:
        prompt_text = prompt_template.user_prompt_template
        # No variables to render for PDF prompt (document is visual)
```

4. After Claude API call, record metrics:
```python
if prompt_template and self.db and self.email_id:
    record_extraction_metrics(
        db=self.db,
        prompt_template_id=prompt_template.id,
        email_id=self.email_id,
        input_tokens=message.usage.input_tokens,
        output_tokens=message.usage.output_tokens,
        model_name='claude-sonnet-4-5-20250514',
        extraction_success=result.gesamtforderung is not None,
        confidence_score=None,  # PDF extraction doesn't have confidence score
        manual_review_required=False,
        execution_time_ms=execution_time_ms
    )
```

Apply same pattern to ImageExtractor:

1. Add imports
2. Modify __init__ to accept db and email_id
3. Load prompt from database: task_type='extraction', name='image'
4. Record metrics after Claude API call

Keep EXTRACTION_PROMPT and IMAGE_EXTRACTION_PROMPT as module-level constants for fallback.
  </action>
  <verify>python -c "from app.services.extraction.pdf_extractor import PDFExtractor; from app.services.extraction.image_extractor import ImageExtractor; print('Extractors imported')"</verify>
  <done>PDF and image extractors load prompts from database, record metrics, fallback to hardcoded constants</done>
</task>

</tasks>

<verification>
1. intent_classifier.py imports get_active_prompt and uses database prompt if available
2. entity_extractor_claude.py loads both system and user prompts from database
3. pdf_extractor.py loads EXTRACTION_PROMPT from database for scanned PDFs
4. image_extractor.py loads IMAGE_EXTRACTION_PROMPT from database
5. All services fall back to hardcoded prompts if no active database version
6. All services record metrics with prompt_template_id when database prompt used
</verification>

<success_criteria>
- All 4 extraction services check database for active prompt first
- Jinja2 variables interpolated correctly (subject, body, from_email)
- Metrics recorded with correct prompt_template_id after each API call
- Hardcoded prompts preserved as fallback for migration period
- No breaking changes to existing callers (new parameters optional)
</success_criteria>

<output>
After completion, create `.planning/phases/08-database-backed-prompt-management/08-03-SUMMARY.md`
</output>
