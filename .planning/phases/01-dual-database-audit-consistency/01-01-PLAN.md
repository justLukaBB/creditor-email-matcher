---
phase: 01-dual-database-audit-consistency
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/outbox_message.py
  - app/models/idempotency_key.py
  - app/models/reconciliation_report.py
  - app/models/incoming_email.py
  - app/models/__init__.py
  - alembic/versions/add_saga_infrastructure.py
autonomous: true

must_haves:
  truths:
    - "OutboxMessage model exists with aggregate_type, operation, payload, idempotency_key, processed_at, retry_count fields"
    - "IdempotencyKey model exists with key, result, created_at, expires_at fields"
    - "ReconciliationReport model exists with run_at, mismatches_found, details, auto_repaired fields"
    - "IncomingEmail model has sync_status, sync_error, sync_retry_count, idempotency_key columns"
    - "Alembic migration runs successfully creating all new tables and columns"
  artifacts:
    - path: "app/models/outbox_message.py"
      provides: "OutboxMessage SQLAlchemy model for transactional outbox pattern"
      contains: "class OutboxMessage"
    - path: "app/models/idempotency_key.py"
      provides: "IdempotencyKey SQLAlchemy model for duplicate prevention"
      contains: "class IdempotencyKey"
    - path: "app/models/reconciliation_report.py"
      provides: "ReconciliationReport model for tracking reconciliation runs"
      contains: "class ReconciliationReport"
    - path: "app/models/incoming_email.py"
      provides: "Extended IncomingEmail with sync tracking columns"
      contains: "sync_status"
  key_links:
    - from: "app/models/__init__.py"
      to: "app/models/outbox_message.py"
      via: "import and __all__ export"
      pattern: "from app.models.outbox_message import OutboxMessage"
    - from: "alembic/versions/add_saga_infrastructure.py"
      to: "app/models/"
      via: "migration creates tables matching models"
      pattern: "op.create_table"
---

<objective>
Create the database foundation for dual-database saga pattern: OutboxMessage table for transactional outbox, IdempotencyKey table for duplicate prevention, ReconciliationReport table for audit trail, and sync tracking columns on IncomingEmail.

Purpose: All subsequent saga pattern work (dual writes, reconciliation, audit) depends on these models and tables existing. This is the foundation layer that must be in place before any business logic.

Output: Four SQLAlchemy models, updated model registry, and Alembic migration that creates all new tables/columns.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-dual-database-audit-consistency/01-RESEARCH.md

@_existing-code/app/models/incoming_email.py
@_existing-code/app/models/__init__.py
@_existing-code/app/database.py
@_existing-code/alembic/env.py
@_existing-code/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create saga infrastructure models and extend IncomingEmail</name>
  <files>
    app/models/outbox_message.py
    app/models/idempotency_key.py
    app/models/reconciliation_report.py
    app/models/incoming_email.py
    app/models/__init__.py
  </files>
  <action>
    1. Create `app/models/outbox_message.py` with OutboxMessage model:
       - id: Integer, primary_key, autoincrement
       - aggregate_type: String(100), not null (e.g., 'creditor_debt_update', 'incoming_email')
       - aggregate_id: String(255), not null (the PostgreSQL record ID this relates to)
       - operation: String(50), not null ('INSERT', 'UPDATE', 'DELETE')
       - payload: JSON, not null (the data to write to MongoDB)
       - idempotency_key: String(255), unique, not null
       - created_at: DateTime(timezone=True), server_default=func.now()
       - processed_at: DateTime(timezone=True), nullable
       - retry_count: Integer, default=0
       - max_retries: Integer, default=5
       - error_message: Text, nullable
       - Index on (processed_at, retry_count) for efficient polling of unprocessed messages
       - Index on created_at for cleanup queries

    2. Create `app/models/idempotency_key.py` with IdempotencyKey model:
       - id: Integer, primary_key, autoincrement
       - key: String(255), unique, not null, indexed
       - result: JSON, nullable (cached result of the operation)
       - created_at: DateTime(timezone=True), server_default=func.now()
       - expires_at: DateTime(timezone=True), not null
       - Note: Cleanup of expired keys handled by reconciliation job (no Redis needed -- Phase 2 adds Redis)

    3. Create `app/models/reconciliation_report.py` with ReconciliationReport model:
       - id: Integer, primary_key, autoincrement
       - run_at: DateTime(timezone=True), server_default=func.now(), not null
       - completed_at: DateTime(timezone=True), nullable
       - records_checked: Integer, default=0
       - mismatches_found: Integer, default=0
       - auto_repaired: Integer, default=0
       - failed_repairs: Integer, default=0
       - details: JSON, nullable (list of mismatch details)
       - status: String(50), default='running' (running, completed, failed)
       - error_message: Text, nullable

    4. Extend `app/models/incoming_email.py` -- add these columns AFTER the existing columns (do NOT change or remove any existing columns, per REQ-MIGRATE-01 backward compatibility):
       - sync_status: String(50), default='pending' (pending, synced, failed, not_applicable)
       - sync_error: Text, nullable
       - sync_retry_count: Integer, default=0
       - idempotency_key: String(255), nullable, unique

    5. Update `app/models/__init__.py` to import and export all new models:
       - Add OutboxMessage, IdempotencyKey, ReconciliationReport to imports and __all__

    IMPORTANT: Use Integer primary keys (not UUIDs) to match existing codebase convention. All existing models use Integer PKs.
    IMPORTANT: Use `from sqlalchemy.sql import func` for server_default timestamps (matching existing pattern in incoming_email.py).
    IMPORTANT: Do NOT use `declarative_base()` -- import `Base` from `app.database` (matching existing pattern).
  </action>
  <verify>
    python -c "from app.models import OutboxMessage, IdempotencyKey, ReconciliationReport, IncomingEmail; print('All models import successfully')"
  </verify>
  <done>
    All four models import without error. OutboxMessage has aggregate_type/operation/payload/idempotency_key/processed_at/retry_count. IdempotencyKey has key/result/expires_at. ReconciliationReport has run_at/mismatches_found/details/auto_repaired. IncomingEmail has sync_status/sync_error/sync_retry_count/idempotency_key columns alongside all existing columns unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration for saga infrastructure tables</name>
  <files>
    alembic/versions/add_saga_infrastructure.py
  </files>
  <action>
    Generate Alembic migration using `alembic revision --autogenerate -m "add_saga_infrastructure"`.

    If autogenerate does not work (requires DB connection), create manual migration with:

    1. `op.create_table('outbox_messages', ...)` matching OutboxMessage model exactly
    2. `op.create_table('idempotency_keys', ...)` matching IdempotencyKey model exactly
    3. `op.create_table('reconciliation_reports', ...)` matching ReconciliationReport model exactly
    4. `op.add_column('incoming_emails', Column('sync_status', String(50), server_default='pending'))`
    5. `op.add_column('incoming_emails', Column('sync_error', Text, nullable=True))`
    6. `op.add_column('incoming_emails', Column('sync_retry_count', Integer, server_default='0'))`
    7. `op.add_column('incoming_emails', Column('idempotency_key', String(255), nullable=True))`
    8. Add unique constraint on incoming_emails.idempotency_key
    9. Add indexes: outbox_messages(processed_at, retry_count), outbox_messages(created_at), idempotency_keys(key), idempotency_keys(expires_at)

    The downgrade function should drop the three new tables and remove the four new columns from incoming_emails.

    Set the revision to depend on the existing initial migration: `20260107_1733_381db1c8de34`.

    IMPORTANT: The migration file should be named with a timestamp prefix matching Alembic conventions.
    IMPORTANT: Import Column, String, Integer, Text, DateTime, JSON from sqlalchemy in the migration.
  </action>
  <verify>
    python -c "from alembic.config import Config; from alembic import command; print('Alembic config valid')" (validates migration file syntax)

    Verify migration file contains: op.create_table for outbox_messages, idempotency_keys, reconciliation_reports, and op.add_column for incoming_emails sync columns.
  </verify>
  <done>
    Alembic migration file exists with correct up/down operations. Creates outbox_messages, idempotency_keys, reconciliation_reports tables. Adds sync_status, sync_error, sync_retry_count, idempotency_key columns to incoming_emails. Downgrade reverses all changes. Migration depends on initial schema migration.
  </done>
</task>

</tasks>

<verification>
1. All model files exist and import cleanly: `python -c "from app.models import OutboxMessage, IdempotencyKey, ReconciliationReport, IncomingEmail"`
2. Alembic migration file exists in alembic/versions/
3. No existing model columns were removed or changed (backward compatibility)
4. IncomingEmail retains all original columns plus new sync tracking columns
</verification>

<success_criteria>
- OutboxMessage, IdempotencyKey, ReconciliationReport models created with all specified fields
- IncomingEmail extended with sync_status, sync_error, sync_retry_count, idempotency_key
- Alembic migration file created with correct up/down operations
- All models importable from app.models
- No changes to existing model columns or table structures
</success_criteria>

<output>
After completion, create `.planning/phases/01-dual-database-audit-consistency/01-01-SUMMARY.md`
</output>
