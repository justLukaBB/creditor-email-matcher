---
phase: 03-multi-format-document-extraction
plan: 04
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - app/services/extraction/email_body_extractor.py
  - app/services/extraction/docx_extractor.py
  - app/services/extraction/xlsx_extractor.py
  - app/services/extraction/__init__.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Email body text extracts Forderungshoehe using regex patterns"
    - "DOCX documents extract text and tables"
    - "XLSX documents extract with read-only mode for memory efficiency"
    - "All extractors return consistent SourceExtractionResult format"
  artifacts:
    - path: "app/services/extraction/email_body_extractor.py"
      provides: "Email body text extraction"
      contains: "class EmailBodyExtractor"
    - path: "app/services/extraction/docx_extractor.py"
      provides: "DOCX text/table extraction"
      contains: "class DOCXExtractor"
    - path: "app/services/extraction/xlsx_extractor.py"
      provides: "Memory-efficient XLSX extraction"
      contains: "class XLSXExtractor"
  key_links:
    - from: "app/services/extraction/docx_extractor.py"
      to: "python-docx"
      via: "Document class"
      pattern: "from docx import Document"
    - from: "app/services/extraction/xlsx_extractor.py"
      to: "openpyxl"
      via: "read_only mode"
      pattern: "load_workbook.*read_only=True"
---

<objective>
Create extractors for email body text, DOCX, and XLSX documents.

Purpose: Email bodies often contain the Forderungshoehe directly. DOCX and XLSX attachments appear in production and need extraction capability. All use native Python libraries (no Claude API cost).

Output: Three extractors returning consistent SourceExtractionResult format.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-format-document-extraction/03-CONTEXT.md
@.planning/phases/03-multi-format-document-extraction/03-RESEARCH.md

# Dependencies from this phase
@app/models/extraction_result.py

# Existing email parsing
@app/services/email_parser.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create email body extractor</name>
  <files>app/services/extraction/email_body_extractor.py</files>
  <action>
Create extractor for email body text that finds Forderungshoehe amounts.

**Class: EmailBodyExtractor**

This is the simplest extractor - it operates on already-cleaned email text.

**Constructor:**
```python
def __init__(self):
    self.amount_patterns = [
        # Explicit Gesamtforderung
        r'[Gg]esamtforderung[:\s]+([0-9.,]+)\s*(EUR|€)',
        r'[Gg]esamt(?:betrag|summe)?[:\s]+([0-9.,]+)\s*(EUR|€)',
        # Forderung patterns
        r'[Ff]orderung(?:shöhe|sbetrag)?[:\s]+([0-9.,]+)\s*(EUR|€)',
        # Generic amount patterns
        r'[Bb]etrag[:\s]+([0-9.,]+)\s*(EUR|€)',
        r'[Ss]umme[:\s]+([0-9.,]+)\s*(EUR|€)',
        # Currency first patterns
        r'(EUR|€)\s*([0-9.,]+)',
    ]
```

**Method: extract(email_text: str) -> SourceExtractionResult**
```python
def extract(self, email_text: str) -> SourceExtractionResult:
    import re

    result = SourceExtractionResult(
        source_type="email_body",
        source_name="email_body",
        extraction_method="text_parsing",
        tokens_used=0  # No API calls
    )

    if not email_text or not email_text.strip():
        result.error = "empty_email_body"
        return result

    # Find all amounts in text
    found_amounts = []

    for pattern in self.amount_patterns:
        for match in re.finditer(pattern, email_text):
            try:
                # Handle both patterns: "1.234,56 EUR" and "EUR 1.234,56"
                groups = match.groups()
                if groups[0] in ('EUR', '€'):
                    amount_str = groups[1]
                else:
                    amount_str = groups[0]

                # Parse German number format
                normalized = amount_str.replace('.', '').replace(',', '.')
                amount_value = float(normalized)

                if amount_value > 0:
                    found_amounts.append({
                        'value': amount_value,
                        'raw': match.group(0),
                        'confidence': 'HIGH' if ',' in amount_str else 'MEDIUM'
                    })
            except ValueError:
                continue

    # Take the highest amount (USER DECISION: highest wins)
    if found_amounts:
        best = max(found_amounts, key=lambda x: x['value'])
        result.gesamtforderung = ExtractedAmount(
            value=best['value'],
            currency="EUR",
            raw_text=best['raw'],
            source="email_body",
            confidence=best['confidence']
        )

    # Basic name extraction from email signatures/headers
    # Note: This is basic - Phase 4 will improve German name extraction
    name_patterns = [
        r'(?:Mandant|Schuldner|Kunde)[:\s]+([A-Za-zäöüÄÖÜß\-,\s]+)',
        r'(?:Gläubiger|Inkasso|Firma)[:\s]+([A-Za-zäöüÄÖÜß\-,\s]+)',
    ]

    for i, pattern in enumerate(name_patterns):
        match = re.search(pattern, email_text)
        if match:
            name = match.group(1).strip()
            if len(name) > 3:  # Filter out too-short matches
                if i == 0:  # Client pattern
                    result.client_name = ExtractedEntity(
                        value=name,
                        entity_type="client_name",
                        confidence="MEDIUM"
                    )
                else:  # Creditor pattern
                    result.creditor_name = ExtractedEntity(
                        value=name,
                        entity_type="creditor_name",
                        confidence="MEDIUM"
                    )

    return result
```

**Implementation notes:**
- No API calls, pure regex extraction
- German number format handling (1.234,56 -> 1234.56)
- Log number of amounts found
- Return highest amount per USER DECISION
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.email_body_extractor import EmailBodyExtractor
from app.models.extraction_result import SourceExtractionResult

extractor = EmailBodyExtractor()

# Test German format
result = extractor.extract('Die Gesamtforderung beträgt 1.234,56 EUR.')
assert result.gesamtforderung is not None
assert abs(result.gesamtforderung.value - 1234.56) < 0.01
print(f'Extracted: {result.gesamtforderung.value} EUR')
print('EmailBodyExtractor OK')
"
```
  </verify>
  <done>EmailBodyExtractor finds Forderungshoehe in email text using regex patterns, parses German number format</done>
</task>

<task type="auto">
  <name>Task 2: Create DOCX extractor</name>
  <files>
app/services/extraction/docx_extractor.py
requirements.txt
  </files>
  <action>
Create DOCX extractor using python-docx library.

**1. Add to requirements.txt:**
```
python-docx>=1.1.0
```

**Class: DOCXExtractor**

**Constructor:**
```python
def __init__(self):
    self.amount_patterns = [...]  # Same patterns as EmailBodyExtractor
```

**Method: extract(docx_path: str) -> SourceExtractionResult**
```python
def extract(self, docx_path: str) -> SourceExtractionResult:
    from docx import Document

    result = SourceExtractionResult(
        source_type="docx",
        source_name=os.path.basename(docx_path),
        extraction_method="python_docx",
        tokens_used=0
    )

    try:
        doc = Document(docx_path)

        # Extract all paragraphs
        all_text = []
        for para in doc.paragraphs:
            if para.text.strip():
                all_text.append(para.text)

        # Extract text from tables
        for table in doc.tables:
            for row in table.rows:
                row_text = ' | '.join(cell.text.strip() for cell in row.cells if cell.text.strip())
                if row_text:
                    all_text.append(row_text)

        combined_text = '\n'.join(all_text)

        # Reuse amount extraction logic
        return self._extract_from_text(combined_text, result)

    except Exception as e:
        result.error = f"docx_extraction_error: {str(e)}"
        return result

def _extract_from_text(self, text: str, result: SourceExtractionResult) -> SourceExtractionResult:
    """Extract amounts from combined text (shared logic with tables)."""
    import re

    found_amounts = []
    for pattern in self.amount_patterns:
        for match in re.finditer(pattern, text):
            try:
                groups = match.groups()
                if groups[0] in ('EUR', '€'):
                    amount_str = groups[1]
                else:
                    amount_str = groups[0]

                normalized = amount_str.replace('.', '').replace(',', '.')
                amount_value = float(normalized)

                if amount_value > 0:
                    found_amounts.append({
                        'value': amount_value,
                        'raw': match.group(0),
                        'confidence': 'HIGH' if ',' in amount_str else 'MEDIUM'
                    })
            except ValueError:
                continue

    if found_amounts:
        best = max(found_amounts, key=lambda x: x['value'])
        result.gesamtforderung = ExtractedAmount(
            value=best['value'],
            currency="EUR",
            raw_text=best['raw'],
            source="docx",
            confidence=best['confidence']
        )

    return result
```

**Implementation notes:**
- Handle corrupted DOCX files gracefully
- Extract from both paragraphs AND tables
- Log paragraph and table counts
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.docx_extractor import DOCXExtractor
print('DOCXExtractor import OK')

# Test instantiation
extractor = DOCXExtractor()
print('DOCXExtractor instantiated OK')
"
# Verify python-docx can import
python -c "from docx import Document; print('python-docx OK')"
```
  </verify>
  <done>DOCXExtractor extracts text from paragraphs and tables, applies same amount patterns as email body</done>
</task>

<task type="auto">
  <name>Task 3: Create XLSX extractor with memory-efficient mode</name>
  <files>
app/services/extraction/xlsx_extractor.py
app/services/extraction/__init__.py
requirements.txt
  </files>
  <action>
Create XLSX extractor using openpyxl with read_only mode for memory efficiency.

**1. Add to requirements.txt:**
```
openpyxl>=3.1.0
```

**Class: XLSXExtractor**

**Constructor:**
```python
def __init__(self):
    self.amount_keywords = [
        'gesamtforderung', 'gesamt', 'forderung', 'betrag', 'summe',
        'total', 'amount', 'schuld', 'forderungshöhe'
    ]
```

**Method: extract(xlsx_path: str) -> SourceExtractionResult**
```python
def extract(self, xlsx_path: str) -> SourceExtractionResult:
    from openpyxl import load_workbook

    result = SourceExtractionResult(
        source_type="xlsx",
        source_name=os.path.basename(xlsx_path),
        extraction_method="openpyxl",
        tokens_used=0
    )

    try:
        # Memory-efficient mode: read_only=True, data_only=True
        wb = load_workbook(xlsx_path, read_only=True, data_only=True)

        found_amounts = []

        for sheet_name in wb.sheetnames:
            sheet = wb[sheet_name]

            for row_idx, row in enumerate(sheet.iter_rows(values_only=True), start=1):
                # Skip empty rows
                if not any(cell is not None for cell in row):
                    continue

                # Look for keyword + value pattern
                for col_idx, cell in enumerate(row):
                    if cell is None:
                        continue

                    cell_str = str(cell).lower()

                    # Check if this cell contains a keyword
                    if any(kw in cell_str for kw in self.amount_keywords):
                        # Look at adjacent cells for numeric value
                        for adjacent_idx in [col_idx + 1, col_idx - 1]:
                            if 0 <= adjacent_idx < len(row):
                                adjacent_cell = row[adjacent_idx]
                                if adjacent_cell is not None:
                                    try:
                                        # Try to parse as number
                                        if isinstance(adjacent_cell, (int, float)):
                                            amount_value = float(adjacent_cell)
                                        else:
                                            # Parse string number (German format)
                                            amount_str = str(adjacent_cell)
                                            normalized = amount_str.replace('.', '').replace(',', '.').replace('€', '').replace('EUR', '').strip()
                                            amount_value = float(normalized)

                                        if amount_value > 0:
                                            found_amounts.append({
                                                'value': amount_value,
                                                'raw': f"{cell}: {adjacent_cell}",
                                                'sheet': sheet_name,
                                                'row': row_idx,
                                                'confidence': 'HIGH' if isinstance(adjacent_cell, (int, float)) else 'MEDIUM'
                                            })
                                    except (ValueError, TypeError):
                                        continue

        wb.close()

        # Take highest amount
        if found_amounts:
            best = max(found_amounts, key=lambda x: x['value'])
            result.gesamtforderung = ExtractedAmount(
                value=best['value'],
                currency="EUR",
                raw_text=best['raw'],
                source="xlsx",
                confidence=best['confidence']
            )

        return result

    except Exception as e:
        result.error = f"xlsx_extraction_error: {str(e)}"
        return result
```

**2. Update app/services/extraction/__init__.py:**
Add all new extractors to exports:
```python
from .detector import detect_file_format, is_scanned_pdf, FileFormat, SUPPORTED_FORMATS
from .email_body_extractor import EmailBodyExtractor
from .docx_extractor import DOCXExtractor
from .xlsx_extractor import XLSXExtractor

__all__ = [
    "detect_file_format",
    "is_scanned_pdf",
    "FileFormat",
    "SUPPORTED_FORMATS",
    "EmailBodyExtractor",
    "DOCXExtractor",
    "XLSXExtractor",
]
```

**Implementation notes:**
- Always use read_only=True and data_only=True for memory efficiency
- Search for amount keywords then check adjacent cells
- Close workbook after processing
- Handle numeric cells differently from string cells
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.xlsx_extractor import XLSXExtractor
print('XLSXExtractor import OK')

extractor = XLSXExtractor()
print(f'Keywords: {extractor.amount_keywords[:3]}...')
print('XLSXExtractor instantiated OK')
"
# Verify openpyxl
python -c "from openpyxl import load_workbook; print('openpyxl OK')"
```
  </verify>
  <done>XLSXExtractor uses read_only mode for memory efficiency, searches for amount keywords and adjacent values</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All three extractors import successfully
2. EmailBodyExtractor parses German number format correctly
3. DOCXExtractor extracts from paragraphs and tables
4. XLSXExtractor uses memory-efficient read_only mode
5. All extractors return consistent SourceExtractionResult format
</verification>

<success_criteria>
- Email body extraction finds Forderungshoehe amounts
- DOCX extraction handles both text and tables
- XLSX extraction uses read_only mode (constant memory)
- All extractors return same SourceExtractionResult structure
- German number format (1.234,56) parsed correctly in all
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-format-document-extraction/03-04-SUMMARY.md`
</output>
