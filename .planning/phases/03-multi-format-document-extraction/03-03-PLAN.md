---
phase: 03-multi-format-document-extraction
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - app/services/extraction/pdf_extractor.py
  - app/services/extraction/__init__.py
autonomous: true

must_haves:
  truths:
    - "Digital PDFs extract text using PyMuPDF without Claude API calls"
    - "Scanned PDFs fall back to Claude Vision API"
    - "PDFs over 10 pages process first 5 + last 5 only"
    - "Password-protected PDFs skip gracefully without crashing"
    - "Token budget checked before Claude Vision calls"
  artifacts:
    - path: "app/services/extraction/pdf_extractor.py"
      provides: "PDF extraction with PyMuPDF + Claude Vision fallback"
      contains: "class PDFExtractor"
    - path: "app/services/extraction/pdf_extractor.py"
      provides: "Scanned PDF handling"
      contains: "extract_with_claude_vision"
  key_links:
    - from: "app/services/extraction/pdf_extractor.py"
      to: "app/services/extraction/detector.py"
      via: "is_scanned_pdf check"
      pattern: "is_scanned_pdf"
    - from: "app/services/extraction/pdf_extractor.py"
      to: "app/services/cost_control/token_budget.py"
      via: "budget checking before API call"
      pattern: "TokenBudgetTracker"
    - from: "app/services/extraction/pdf_extractor.py"
      to: "anthropic"
      via: "Claude Vision API for scanned PDFs"
      pattern: "client\\.messages\\.create"
---

<objective>
Create PDF extraction service with PyMuPDF for digital PDFs and Claude Vision API fallback for scanned documents.

Purpose: PDFs are the primary attachment format for creditor documents. Digital PDFs (text-selectable) extract instantly with PyMuPDF. Scanned PDFs require Claude Vision but represent the minority of documents.

Output: PDFExtractor class that automatically routes to appropriate extraction method based on PDF type.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-format-document-extraction/03-CONTEXT.md
@.planning/phases/03-multi-format-document-extraction/03-RESEARCH.md

# Dependencies from this phase
@app/models/extraction_result.py
@app/services/cost_control/token_budget.py
@app/services/extraction/detector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create PDFExtractor with PyMuPDF for digital PDFs</name>
  <files>app/services/extraction/pdf_extractor.py</files>
  <action>
Create the PDFExtractor class with PyMuPDF extraction for digital PDFs.

**Class: PDFExtractor**

**Constructor:**
```python
def __init__(
    self,
    token_budget: TokenBudgetTracker,
    claude_client: Optional[Anthropic] = None,
    max_pages: int = 10
):
    self.token_budget = token_budget
    self.claude_client = claude_client or Anthropic()
    self.max_pages = max_pages
```

**Method: extract(pdf_path: str) -> SourceExtractionResult**
Main entry point that routes to PyMuPDF or Claude Vision:
```python
def extract(self, pdf_path: str) -> SourceExtractionResult:
    # Check if encrypted
    if is_encrypted_pdf(pdf_path):
        return SourceExtractionResult(
            source_type="pdf",
            source_name=os.path.basename(pdf_path),
            error="encrypted_pdf_skipped",
            extraction_method="skipped"
        )

    # Route based on PDF type
    if is_scanned_pdf(pdf_path):
        return self._extract_with_claude_vision(pdf_path)
    else:
        return self._extract_with_pymupdf(pdf_path)
```

**Method: _extract_with_pymupdf(pdf_path: str) -> SourceExtractionResult**
For digital PDFs:
```python
def _extract_with_pymupdf(self, pdf_path: str) -> SourceExtractionResult:
    import fitz

    doc = fitz.open(pdf_path)
    try:
        total_pages = len(doc)

        # Handle >10 page limit: first 5 + last 5 (USER DECISION)
        if total_pages > self.max_pages:
            pages_to_process = list(range(5)) + list(range(total_pages - 5, total_pages))
        else:
            pages_to_process = list(range(total_pages))

        # Extract text from selected pages
        all_text = []
        for page_num in pages_to_process:
            page = doc[page_num]
            text = page.get_text("text", sort=True)  # sort=True for natural reading order
            all_text.append(text)

        combined_text = "\n\n".join(all_text)

        # Parse extracted text for Forderungshoehe
        return self._parse_text_for_entities(
            text=combined_text,
            source_name=os.path.basename(pdf_path),
            extraction_method="pymupdf"
        )
    finally:
        doc.close()
```

**Method: _parse_text_for_entities(text: str, source_name: str, extraction_method: str) -> SourceExtractionResult**
Parse extracted text to find Gesamtforderung, client_name, creditor_name:
```python
def _parse_text_for_entities(self, text: str, source_name: str, extraction_method: str) -> SourceExtractionResult:
    import re

    result = SourceExtractionResult(
        source_type="pdf",
        source_name=source_name,
        extraction_method=extraction_method,
        tokens_used=0
    )

    # Search for Gesamtforderung patterns (German currency formats)
    # Patterns: "Gesamtforderung: 1.234,56 EUR", "Gesamt: EUR 1234.56", etc.
    amount_patterns = [
        r'[Gg]esamtforderung[:\s]+([0-9.,]+)\s*(EUR|€)',
        r'[Gg]esamt[:\s]+([0-9.,]+)\s*(EUR|€)',
        r'[Ff]orderung[:\s]+([0-9.,]+)\s*(EUR|€)',
        r'[Bb]etrag[:\s]+([0-9.,]+)\s*(EUR|€)',
        r'(EUR|€)\s*([0-9.,]+)',
    ]

    for pattern in amount_patterns:
        match = re.search(pattern, text)
        if match:
            # Parse German number format (1.234,56 -> 1234.56)
            amount_str = match.group(1) if match.group(1) not in ('EUR', '€') else match.group(2)
            try:
                # German format: 1.234,56 -> replace . with '', then , with .
                normalized = amount_str.replace('.', '').replace(',', '.')
                amount_value = float(normalized)

                result.gesamtforderung = ExtractedAmount(
                    value=amount_value,
                    currency="EUR",
                    raw_text=match.group(0),
                    source="pdf",
                    confidence="HIGH" if re.match(r'\d+[.,]\d{2}', amount_str) else "MEDIUM"
                )
                break
            except ValueError:
                continue

    # Note: client_name and creditor_name extraction is basic here
    # Phase 4 (German Document Extraction) will improve this
    # For now, return what we found

    return result
```

**Implementation notes:**
- Import structlog for logging
- Log which extraction method was used
- Log page count and pages processed
- Handle fitz exceptions gracefully
- Memory management: close doc in finally block
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.pdf_extractor import PDFExtractor
from app.services.cost_control import TokenBudgetTracker
from app.models.extraction_result import SourceExtractionResult

tracker = TokenBudgetTracker()
extractor = PDFExtractor(token_budget=tracker)
print('PDFExtractor instantiated OK')
print(f'Max pages: {extractor.max_pages}')
"
```
  </verify>
  <done>PDFExtractor routes to PyMuPDF for digital PDFs, parses German currency formats, handles page limits</done>
</task>

<task type="auto">
  <name>Task 2: Add Claude Vision fallback for scanned PDFs</name>
  <files>app/services/extraction/pdf_extractor.py</files>
  <action>
Add Claude Vision API integration for scanned PDFs to the PDFExtractor class.

**Method: _extract_with_claude_vision(pdf_path: str) -> SourceExtractionResult**
```python
def _extract_with_claude_vision(self, pdf_path: str) -> SourceExtractionResult:
    import base64
    import fitz
    import json

    doc = fitz.open(pdf_path)
    try:
        total_pages = len(doc)

        # Handle >10 page limit (USER DECISION: first 5 + last 5)
        if total_pages > self.max_pages:
            pages_to_process = list(range(5)) + list(range(total_pages - 5, total_pages))
            logger.info("pdf_truncated", total_pages=total_pages, processing=len(pages_to_process))
        else:
            pages_to_process = list(range(total_pages))

        # Estimate tokens: ~2000 per page for Claude Vision
        estimated_tokens = len(pages_to_process) * 2000

        # Check token budget BEFORE calling API
        if not self.token_budget.check_budget(estimated_tokens):
            return SourceExtractionResult(
                source_type="pdf",
                source_name=os.path.basename(pdf_path),
                error=f"token_budget_exceeded: would need {estimated_tokens}, remaining {self.token_budget.remaining()}",
                extraction_method="claude_vision_skipped"
            )

        # Read PDF as base64
        with open(pdf_path, "rb") as f:
            pdf_data = base64.standard_b64encode(f.read()).decode("utf-8")

        # Call Claude Vision API
        message = self.claude_client.messages.create(
            model="claude-sonnet-4-5-20250514",
            max_tokens=2048,
            messages=[{
                "role": "user",
                "content": [
                    {
                        "type": "document",
                        "source": {
                            "type": "base64",
                            "media_type": "application/pdf",
                            "data": pdf_data
                        }
                    },
                    {
                        "type": "text",
                        "text": EXTRACTION_PROMPT
                    }
                ]
            }]
        )

        # Record token usage
        tokens_used = message.usage.input_tokens + message.usage.output_tokens
        self.token_budget.add_usage(message.usage.input_tokens, message.usage.output_tokens)

        # Parse response
        return self._parse_claude_response(
            response_text=message.content[0].text,
            source_name=os.path.basename(pdf_path),
            tokens_used=tokens_used
        )
    finally:
        doc.close()
```

**Constant: EXTRACTION_PROMPT**
```python
EXTRACTION_PROMPT = """Analyze this German creditor document and extract the following information.

IMPORTANT RULES:
1. Look for "Gesamtforderung" (total claim) - this is the main amount we need
2. If no explicit Gesamtforderung: Sum "Hauptforderung" + "Zinsen" + "Kosten"
3. Parse German number format: 1.234,56 EUR means 1234.56

Extract:
1. gesamtforderung: The total claim amount in EUR (numeric only, e.g., 1234.56)
2. glaeubiger: Creditor/company name
3. schuldner: Debtor/client name
4. components: If Gesamtforderung not explicit, provide breakdown

Return ONLY valid JSON in this exact format:
{
  "gesamtforderung": 1234.56,
  "glaeubiger": "Company Name",
  "schuldner": "Person Name",
  "components": {
    "hauptforderung": 1000.00,
    "zinsen": 150.56,
    "kosten": 84.00
  }
}

If a field cannot be found, use null. For gesamtforderung, return null only if no amounts are found at all."""
```

**Method: _parse_claude_response(response_text: str, source_name: str, tokens_used: int) -> SourceExtractionResult**
```python
def _parse_claude_response(self, response_text: str, source_name: str, tokens_used: int) -> SourceExtractionResult:
    import json
    import re

    result = SourceExtractionResult(
        source_type="pdf",
        source_name=source_name,
        extraction_method="claude_vision",
        tokens_used=tokens_used
    )

    try:
        # Extract JSON from response (handle markdown code blocks)
        json_match = re.search(r'\{[\s\S]*\}', response_text)
        if not json_match:
            result.error = "no_json_in_response"
            return result

        data = json.loads(json_match.group())

        # Extract Gesamtforderung
        if data.get("gesamtforderung") is not None:
            result.gesamtforderung = ExtractedAmount(
                value=float(data["gesamtforderung"]),
                currency="EUR",
                source="pdf",
                confidence="HIGH"  # Claude extraction is generally high confidence
            )
        elif data.get("components"):
            # Sum components (USER DECISION)
            components = data["components"]
            total = sum(v for v in components.values() if v is not None)
            if total > 0:
                result.gesamtforderung = ExtractedAmount(
                    value=total,
                    currency="EUR",
                    source="pdf",
                    confidence="MEDIUM"  # Computed, not explicit
                )
            result.components = components

        # Extract names
        if data.get("glaeubiger"):
            result.creditor_name = ExtractedEntity(
                value=data["glaeubiger"],
                entity_type="creditor_name",
                confidence="HIGH" if len(data["glaeubiger"]) > 5 else "MEDIUM"
            )

        if data.get("schuldner"):
            result.client_name = ExtractedEntity(
                value=data["schuldner"],
                entity_type="client_name",
                confidence="HIGH" if len(data["schuldner"]) > 5 else "MEDIUM"
            )

    except json.JSONDecodeError as e:
        result.error = f"json_parse_error: {str(e)}"
    except Exception as e:
        result.error = f"extraction_error: {str(e)}"

    return result
```

**Update __init__.py:**
Add PDFExtractor to exports in app/services/extraction/__init__.py

**Implementation notes:**
- Use claude-sonnet-4-5-20250514 model (current version)
- Log token usage after each call
- Handle JSON parsing errors gracefully
- Return partial results if some fields found
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.pdf_extractor import PDFExtractor, EXTRACTION_PROMPT
from app.services.cost_control import TokenBudgetTracker

tracker = TokenBudgetTracker()
extractor = PDFExtractor(token_budget=tracker)

# Check prompt exists
assert 'Gesamtforderung' in EXTRACTION_PROMPT
assert 'JSON' in EXTRACTION_PROMPT
print('PDFExtractor with Claude Vision OK')
print(f'Prompt length: {len(EXTRACTION_PROMPT)} chars')
"
```
  </verify>
  <done>Claude Vision fallback extracts from scanned PDFs with structured prompt, checks token budget before API calls, parses JSON response</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. PDFExtractor instantiates with TokenBudgetTracker
2. PyMuPDF extraction handles German currency formats
3. Claude Vision fallback has structured extraction prompt
4. Token budget is checked before API calls
5. Page limit handling (first 5 + last 5) implemented
</verification>

<success_criteria>
- Digital PDFs extract with PyMuPDF (no API cost)
- Scanned PDFs use Claude Vision with token budget check
- PDFs >10 pages process first 5 + last 5 pages only
- Encrypted PDFs return graceful skip result
- German currency formats (1.234,56 EUR) parsed correctly
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-format-document-extraction/03-03-SUMMARY.md`
</output>
