---
phase: 03-multi-format-document-extraction
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-03", "03-04"]
files_modified:
  - app/services/extraction/image_extractor.py
  - app/services/extraction/consolidator.py
  - app/services/extraction/__init__.py
  - requirements.txt
autonomous: true

must_haves:
  truths:
    - "Images (JPG, PNG) extract via Claude Vision API"
    - "Token budget checked before image API calls"
    - "Consolidator applies highest-amount-wins rule"
    - "Consolidator defaults to 100 EUR when no amount found"
    - "Final confidence is weakest link across all sources"
  artifacts:
    - path: "app/services/extraction/image_extractor.py"
      provides: "Image extraction via Claude Vision"
      contains: "class ImageExtractor"
    - path: "app/services/extraction/consolidator.py"
      provides: "Multi-source consolidation with business rules"
      contains: "class ExtractionConsolidator"
  key_links:
    - from: "app/services/extraction/image_extractor.py"
      to: "anthropic"
      via: "Claude Vision for images"
      pattern: "client\\.messages\\.create"
    - from: "app/services/extraction/consolidator.py"
      to: "app/models/extraction_result.py"
      via: "ConsolidatedExtractionResult"
      pattern: "ConsolidatedExtractionResult"
---

<objective>
Create image extractor for JPG/PNG attachments and consolidator to merge results from all sources.

Purpose: Images appear in production attachments and need Claude Vision extraction. The consolidator applies business rules (highest-amount-wins, 100 EUR default) to produce final extraction result.

Output: ImageExtractor for visual documents, ExtractionConsolidator for multi-source merging.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-format-document-extraction/03-CONTEXT.md
@.planning/phases/03-multi-format-document-extraction/03-RESEARCH.md

# Dependencies from this phase
@app/models/extraction_result.py
@app/services/cost_control/token_budget.py
@app/services/extraction/pdf_extractor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create image extractor with Claude Vision</name>
  <files>
app/services/extraction/image_extractor.py
requirements.txt
  </files>
  <action>
Create image extractor for JPG/PNG using Claude Vision API.

**1. Add to requirements.txt:**
```
Pillow>=10.0.0
```

**Class: ImageExtractor**

**Constructor:**
```python
def __init__(
    self,
    token_budget: TokenBudgetTracker,
    claude_client: Optional[Anthropic] = None,
    max_image_size_kb: int = 5000  # 5MB max before resize
):
    self.token_budget = token_budget
    self.claude_client = claude_client or Anthropic()
    self.max_image_size_kb = max_image_size_kb
```

**Method: extract(image_path: str) -> SourceExtractionResult**
```python
def extract(self, image_path: str) -> SourceExtractionResult:
    import base64
    import os
    from PIL import Image

    result = SourceExtractionResult(
        source_type="image",
        source_name=os.path.basename(image_path),
        extraction_method="claude_vision",
        tokens_used=0
    )

    try:
        # Check file size and resize if needed
        file_size_kb = os.path.getsize(image_path) / 1024
        if file_size_kb > self.max_image_size_kb:
            image_path = self._resize_image(image_path)

        # Estimate tokens: ~1000 tokens for typical image
        estimated_tokens = 2000

        # Check token budget
        if not self.token_budget.check_budget(estimated_tokens):
            result.error = f"token_budget_exceeded: would need {estimated_tokens}, remaining {self.token_budget.remaining()}"
            return result

        # Determine media type
        ext = os.path.splitext(image_path)[1].lower()
        media_type = "image/jpeg" if ext in ['.jpg', '.jpeg'] else "image/png"

        # Read and encode image
        with open(image_path, "rb") as f:
            image_data = base64.standard_b64encode(f.read()).decode("utf-8")

        # Call Claude Vision API
        message = self.claude_client.messages.create(
            model="claude-sonnet-4-5-20250514",
            max_tokens=1024,
            messages=[{
                "role": "user",
                "content": [
                    {
                        "type": "image",
                        "source": {
                            "type": "base64",
                            "media_type": media_type,
                            "data": image_data
                        }
                    },
                    {
                        "type": "text",
                        "text": IMAGE_EXTRACTION_PROMPT
                    }
                ]
            }]
        )

        # Record token usage
        tokens_used = message.usage.input_tokens + message.usage.output_tokens
        self.token_budget.add_usage(message.usage.input_tokens, message.usage.output_tokens)
        result.tokens_used = tokens_used

        # Parse response
        return self._parse_response(message.content[0].text, result)

    except Exception as e:
        result.error = f"image_extraction_error: {str(e)}"
        return result
```

**Constant: IMAGE_EXTRACTION_PROMPT**
```python
IMAGE_EXTRACTION_PROMPT = """Analyze this image of a German creditor/debt document.

Extract the following information if visible:
1. Gesamtforderung (total claim amount) - look for currency amounts in EUR
2. If no total: Sum Hauptforderung + Zinsen + Kosten
3. GlÃ¤ubiger (creditor name)
4. Schuldner (debtor/client name)

German number format: 1.234,56 EUR means 1234.56

Return ONLY valid JSON:
{
  "gesamtforderung": 1234.56,
  "glaeubiger": "Company Name",
  "schuldner": "Person Name"
}

If information is not visible or the image is not a relevant document, return:
{"gesamtforderung": null, "glaeubiger": null, "schuldner": null}"""
```

**Method: _resize_image(image_path: str) -> str**
```python
def _resize_image(self, image_path: str) -> str:
    """Resize large images to reduce token usage."""
    from PIL import Image
    import tempfile
    import os

    img = Image.open(image_path)

    # Calculate new size (max 1500px on longest side)
    max_size = 1500
    ratio = min(max_size / img.width, max_size / img.height)

    if ratio < 1:
        new_size = (int(img.width * ratio), int(img.height * ratio))
        img = img.resize(new_size, Image.LANCZOS)

    # Save to temp file
    _, ext = os.path.splitext(image_path)
    fd, temp_path = tempfile.mkstemp(suffix=ext)
    os.close(fd)

    img.save(temp_path, quality=85)
    img.close()

    return temp_path
```

**Method: _parse_response(response_text: str, result: SourceExtractionResult) -> SourceExtractionResult**
```python
def _parse_response(self, response_text: str, result: SourceExtractionResult) -> SourceExtractionResult:
    import json
    import re

    try:
        json_match = re.search(r'\{[\s\S]*\}', response_text)
        if not json_match:
            result.error = "no_json_in_response"
            return result

        data = json.loads(json_match.group())

        if data.get("gesamtforderung") is not None:
            result.gesamtforderung = ExtractedAmount(
                value=float(data["gesamtforderung"]),
                currency="EUR",
                source="image",
                confidence="MEDIUM"  # Images typically lower confidence
            )

        if data.get("glaeubiger"):
            result.creditor_name = ExtractedEntity(
                value=data["glaeubiger"],
                entity_type="creditor_name",
                confidence="MEDIUM"
            )

        if data.get("schuldner"):
            result.client_name = ExtractedEntity(
                value=data["schuldner"],
                entity_type="client_name",
                confidence="MEDIUM"
            )

    except (json.JSONDecodeError, KeyError, ValueError) as e:
        result.error = f"parse_error: {str(e)}"

    return result
```

**Implementation notes:**
- Resize large images before sending to Claude (reduce tokens)
- Use image media type not document type
- Lower confidence than PDF (MEDIUM default)
- Clean up resized temp files
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.image_extractor import ImageExtractor, IMAGE_EXTRACTION_PROMPT
from app.services.cost_control import TokenBudgetTracker

tracker = TokenBudgetTracker()
extractor = ImageExtractor(token_budget=tracker)

assert 'Gesamtforderung' in IMAGE_EXTRACTION_PROMPT
print('ImageExtractor instantiated OK')
"
# Verify Pillow
python -c "from PIL import Image; print('Pillow OK')"
```
  </verify>
  <done>ImageExtractor uses Claude Vision for JPG/PNG, resizes large images, checks token budget before API calls</done>
</task>

<task type="auto">
  <name>Task 2: Create extraction consolidator with business rules</name>
  <files>
app/services/extraction/consolidator.py
app/services/extraction/__init__.py
  </files>
  <action>
Create consolidator that merges extraction results from all sources using business rules.

**Class: ExtractionConsolidator**

**USER DECISIONS (LOCKED):**
1. Email body + attachments: **highest amount wins**
2. No amount found anywhere: **default to 100 EUR**
3. Confidence: **weakest link** across all sources

**Constructor:**
```python
def __init__(self, default_amount: float = 100.0):
    self.default_amount = default_amount  # USER DECISION: 100 EUR default
```

**Method: consolidate(source_results: List[SourceExtractionResult]) -> ConsolidatedExtractionResult**
```python
def consolidate(self, source_results: List[SourceExtractionResult]) -> ConsolidatedExtractionResult:
    """
    Merge extraction results from all sources.

    Business rules (USER DECISIONS):
    1. Highest amount wins when multiple sources have amounts
    2. Default to 100 EUR if no amount found
    3. Final confidence is weakest link
    """
    # Collect all amounts
    all_amounts: List[ExtractedAmount] = []
    all_client_names: List[ExtractedEntity] = []
    all_creditor_names: List[ExtractedEntity] = []
    total_tokens = 0
    confidences: List[str] = []

    for result in source_results:
        total_tokens += result.tokens_used

        if result.gesamtforderung:
            all_amounts.append(result.gesamtforderung)
            confidences.append(result.gesamtforderung.confidence)

        if result.client_name:
            all_client_names.append(result.client_name)
            confidences.append(result.client_name.confidence)

        if result.creditor_name:
            all_creditor_names.append(result.creditor_name)
            confidences.append(result.creditor_name.confidence)

    # Apply highest-amount-wins rule
    if all_amounts:
        # Deduplicate: amounts within 1 EUR are considered same
        unique_amounts = self._deduplicate_amounts(all_amounts)
        best_amount = max(unique_amounts, key=lambda x: x.value)
        final_amount = best_amount.value
    else:
        # USER DECISION: default to 100 EUR
        final_amount = self.default_amount
        confidences.append("LOW")  # Default amount = low confidence

    # Pick best names (prefer HIGH confidence, then longest name)
    final_client_name = self._pick_best_name(all_client_names)
    final_creditor_name = self._pick_best_name(all_creditor_names)

    # Calculate final confidence (weakest link)
    if not confidences:
        final_confidence = "LOW"
    else:
        confidence_order = {"LOW": 0, "MEDIUM": 1, "HIGH": 2}
        min_conf = min(confidences, key=lambda c: confidence_order.get(c, 0))
        final_confidence = min_conf

    return ConsolidatedExtractionResult(
        gesamtforderung=final_amount,
        client_name=final_client_name,
        creditor_name=final_creditor_name,
        confidence=final_confidence,
        sources_processed=len(source_results),
        sources_with_amount=len(all_amounts),
        total_tokens_used=total_tokens,
        source_results=source_results
    )

def _deduplicate_amounts(self, amounts: List[ExtractedAmount]) -> List[ExtractedAmount]:
    """Deduplicate amounts within 1 EUR of each other."""
    if not amounts:
        return []

    # Sort by value descending
    sorted_amounts = sorted(amounts, key=lambda x: x.value, reverse=True)

    unique = [sorted_amounts[0]]
    for amount in sorted_amounts[1:]:
        # Check if within 1 EUR of any existing
        if not any(abs(amount.value - existing.value) < 1.0 for existing in unique):
            unique.append(amount)

    return unique

def _pick_best_name(self, names: List[ExtractedEntity]) -> Optional[str]:
    """Pick the best name from candidates."""
    if not names:
        return None

    # Prefer HIGH confidence
    high_conf = [n for n in names if n.confidence == "HIGH"]
    if high_conf:
        # Among HIGH confidence, pick longest (more complete)
        return max(high_conf, key=lambda n: len(n.value)).value

    # Fall back to longest name
    return max(names, key=lambda n: len(n.value)).value
```

**2. Update app/services/extraction/__init__.py:**
```python
from .detector import detect_file_format, is_scanned_pdf, FileFormat, SUPPORTED_FORMATS
from .email_body_extractor import EmailBodyExtractor
from .docx_extractor import DOCXExtractor
from .xlsx_extractor import XLSXExtractor
from .pdf_extractor import PDFExtractor
from .image_extractor import ImageExtractor
from .consolidator import ExtractionConsolidator

__all__ = [
    "detect_file_format",
    "is_scanned_pdf",
    "FileFormat",
    "SUPPORTED_FORMATS",
    "EmailBodyExtractor",
    "DOCXExtractor",
    "XLSXExtractor",
    "PDFExtractor",
    "ImageExtractor",
    "ExtractionConsolidator",
]
```

**Implementation notes:**
- Log consolidation decisions (how many sources, which won)
- Handle empty source_results list
- Track which source contributed final amount
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction.consolidator import ExtractionConsolidator
from app.models.extraction_result import SourceExtractionResult, ExtractedAmount, ConsolidatedExtractionResult

consolidator = ExtractionConsolidator()

# Test highest-amount-wins
results = [
    SourceExtractionResult(
        source_type='email_body',
        source_name='email',
        extraction_method='text_parsing',
        gesamtforderung=ExtractedAmount(value=100.0, currency='EUR', source='email_body', confidence='MEDIUM')
    ),
    SourceExtractionResult(
        source_type='pdf',
        source_name='invoice.pdf',
        extraction_method='pymupdf',
        gesamtforderung=ExtractedAmount(value=250.0, currency='EUR', source='pdf', confidence='HIGH')
    )
]

consolidated = consolidator.consolidate(results)
assert consolidated.gesamtforderung == 250.0  # Highest wins
print(f'Consolidated amount: {consolidated.gesamtforderung} EUR')
print(f'Confidence: {consolidated.confidence}')
print('ExtractionConsolidator OK')
"

# Test 100 EUR default
python -c "
from app.services.extraction.consolidator import ExtractionConsolidator
from app.models.extraction_result import SourceExtractionResult

consolidator = ExtractionConsolidator()
results = [SourceExtractionResult(source_type='email_body', source_name='email', extraction_method='text_parsing')]
consolidated = consolidator.consolidate(results)
assert consolidated.gesamtforderung == 100.0  # Default
print(f'Default amount: {consolidated.gesamtforderung} EUR')
print('100 EUR default OK')
"
```
  </verify>
  <done>ExtractionConsolidator merges all sources using highest-amount-wins, defaults to 100 EUR, calculates weakest-link confidence</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. ImageExtractor uses Claude Vision for JPG/PNG
2. Token budget checked before image API calls
3. Consolidator applies highest-amount-wins correctly
4. Consolidator defaults to 100 EUR when no amounts
5. All extractors exported from __init__.py
</verification>

<success_criteria>
- Images extract via Claude Vision with token budget check
- Large images resized before API call
- Consolidator produces final amount using highest-wins rule
- Empty extraction defaults to 100 EUR (business rule)
- Confidence reflects weakest source
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-format-document-extraction/03-05-SUMMARY.md`
</output>
