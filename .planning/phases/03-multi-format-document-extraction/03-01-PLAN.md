---
phase: 03-multi-format-document-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/models/extraction_result.py
  - app/services/cost_control/__init__.py
  - app/services/cost_control/token_budget.py
  - app/services/cost_control/circuit_breaker.py
autonomous: true

must_haves:
  truths:
    - "Extraction results have consistent structure across all extractors"
    - "Token usage tracked per job with hard budget limit"
    - "Daily cost circuit breaker prevents cost explosions"
  artifacts:
    - path: "app/models/extraction_result.py"
      provides: "Pydantic models for extraction output"
      contains: "class ExtractionResult"
    - path: "app/services/cost_control/token_budget.py"
      provides: "Per-job token budget tracking"
      contains: "class TokenBudgetTracker"
    - path: "app/services/cost_control/circuit_breaker.py"
      provides: "Daily cost limit enforcement"
      contains: "class DailyCostCircuitBreaker"
  key_links:
    - from: "app/services/cost_control/token_budget.py"
      to: "app/config.settings"
      via: "max_tokens_per_job configuration"
      pattern: "settings"
    - from: "app/services/cost_control/circuit_breaker.py"
      to: "Redis"
      via: "atomic counter for daily spend"
      pattern: "redis.*incrbyfloat"
---

<objective>
Create foundational models and cost control infrastructure for multi-format document extraction.

Purpose: Establishes consistent data structures for extraction results and prevents Claude API cost explosions through per-job token budgets and daily spend circuit breaker.

Output: Pydantic models for extraction results, token budget tracker, and Redis-backed daily cost circuit breaker.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-format-document-extraction/03-CONTEXT.md
@.planning/phases/03-multi-format-document-extraction/03-RESEARCH.md

# Existing patterns to follow
@app/config.py
@app/models/incoming_email.py
@app/actors/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create extraction result Pydantic models</name>
  <files>app/models/extraction_result.py</files>
  <action>
Create Pydantic models for structured extraction output that all extractors will return.

**Models to create:**

1. `ExtractedAmount` - Represents a monetary amount with metadata:
   - `value: float` - The numeric amount
   - `currency: str = "EUR"` - Currency code
   - `raw_text: Optional[str]` - Original text before parsing
   - `source: str` - Where this was found ("email_body", "pdf", "docx", "xlsx", "image")
   - `confidence: Literal["HIGH", "MEDIUM", "LOW"]` - Based on format precision

2. `ExtractedEntity` - Name extraction result:
   - `value: str` - The extracted name
   - `entity_type: Literal["client_name", "creditor_name"]`
   - `confidence: Literal["HIGH", "MEDIUM", "LOW"]`

3. `SourceExtractionResult` - Result from a single source (one attachment or email body):
   - `source_type: Literal["email_body", "pdf", "docx", "xlsx", "image"]`
   - `source_name: Optional[str]` - Filename for attachments
   - `gesamtforderung: Optional[ExtractedAmount]`
   - `components: Optional[dict]` - {"hauptforderung": float, "zinsen": float, "kosten": float}
   - `client_name: Optional[ExtractedEntity]`
   - `creditor_name: Optional[ExtractedEntity]`
   - `extraction_method: Literal["pymupdf", "claude_vision", "python_docx", "openpyxl", "text_parsing"]`
   - `tokens_used: int = 0`
   - `error: Optional[str]` - If extraction failed for this source

4. `ConsolidatedExtractionResult` - Final merged result:
   - `gesamtforderung: float` - Final amount (highest-wins or 100 EUR default)
   - `client_name: Optional[str]`
   - `creditor_name: Optional[str]`
   - `confidence: Literal["HIGH", "MEDIUM", "LOW"]` - Weakest link
   - `sources_processed: int`
   - `sources_with_amount: int`
   - `total_tokens_used: int`
   - `source_results: List[SourceExtractionResult]`

**Implementation notes:**
- Use Pydantic v2 model_validator for computed fields
- Add `model_config = ConfigDict(from_attributes=True)` for ORM compatibility
- Confidence is heuristic: precise currency format = HIGH, numeric = MEDIUM, missing = LOW
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "from app.models.extraction_result import ExtractionResult, SourceExtractionResult, ConsolidatedExtractionResult, ExtractedAmount; print('Models import OK')"
```
  </verify>
  <done>Pydantic models exist with all required fields, import without errors, and can be instantiated</done>
</task>

<task type="auto">
  <name>Task 2: Create token budget tracker and daily circuit breaker</name>
  <files>
app/services/cost_control/__init__.py
app/services/cost_control/token_budget.py
app/services/cost_control/circuit_breaker.py
app/config.py
  </files>
  <action>
Create cost control services for Claude API usage.

**1. Update app/config.py** - Add settings:
```python
# Cost Control (Phase 3)
max_tokens_per_job: int = 100000  # 100K tokens per extraction job
daily_cost_limit_usd: float = 50.0  # Daily Claude API spend limit
claude_input_cost_per_million: float = 3.0  # Sonnet 4.5 pricing
claude_output_cost_per_million: float = 15.0
```

**2. Create app/services/cost_control/__init__.py**:
```python
from .token_budget import TokenBudgetTracker, TokenBudgetExceeded
from .circuit_breaker import DailyCostCircuitBreaker, DailyLimitExceeded

__all__ = [
    "TokenBudgetTracker",
    "TokenBudgetExceeded",
    "DailyCostCircuitBreaker",
    "DailyLimitExceeded"
]
```

**3. Create app/services/cost_control/token_budget.py**:
- `TokenBudgetExceeded(Exception)` - Raised when budget exceeded
- `TokenBudgetTracker` class:
  - `__init__(max_tokens: int = None)` - Uses settings.max_tokens_per_job if not provided
  - `used_tokens: int = 0`
  - `check_budget(estimated_tokens: int) -> bool` - Returns True if within budget
  - `add_usage(input_tokens: int, output_tokens: int)` - Record usage
  - `remaining() -> int` - Tokens left in budget
  - `estimate_cost_usd() -> float` - Calculate cost from token usage
  - `would_exceed(estimated_tokens: int) -> bool` - Check without raising

**4. Create app/services/cost_control/circuit_breaker.py**:
- `DailyLimitExceeded(Exception)` - Raised when daily limit hit
- `DailyCostCircuitBreaker` class:
  - `__init__(redis_client, daily_limit_usd: float = None)` - Uses settings if not provided
  - Key format: `creditor_matcher:daily_cost:{YYYY-MM-DD}`
  - `check_and_record(estimated_cost_usd: float) -> bool` - Check limit, record if OK
  - `get_current_spend() -> float` - Get today's spend
  - `is_open() -> bool` - True if limit exceeded (circuit is "open")
  - Uses Redis INCRBYFLOAT for atomic increment
  - Sets key TTL to 48 hours (keep 2 days for debugging)

**Implementation notes:**
- Import structlog for logging
- Log warnings when >80% of budget used
- Log errors when budget exceeded
- Circuit breaker should be injectable (for testing with mock Redis)
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.cost_control import TokenBudgetTracker, TokenBudgetExceeded
tracker = TokenBudgetTracker(max_tokens=1000)
assert tracker.check_budget(500) == True
tracker.add_usage(400, 100)
assert tracker.remaining() == 500
print('TokenBudgetTracker OK')
"
python -c "
from app.services.cost_control import DailyCostCircuitBreaker
# Just check import works (Redis not available in test)
print('DailyCostCircuitBreaker import OK')
"
```
  </verify>
  <done>TokenBudgetTracker tracks per-job usage with configurable limit, DailyCostCircuitBreaker uses Redis atomic counters for daily spend</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `python -c "from app.models.extraction_result import *"` succeeds
2. `python -c "from app.services.cost_control import *"` succeeds
3. TokenBudgetTracker correctly calculates remaining budget
4. Settings include cost control configuration
</verification>

<success_criteria>
- ExtractionResult models define consistent structure for all extractors
- TokenBudgetTracker enforces 100K token limit per job
- DailyCostCircuitBreaker ready for Redis-backed daily limit
- All imports work without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-format-document-extraction/03-01-SUMMARY.md`
</output>
