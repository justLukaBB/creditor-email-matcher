---
phase: 03-multi-format-document-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/storage/__init__.py
  - app/services/storage/gcs_client.py
  - app/services/extraction/__init__.py
  - app/services/extraction/detector.py
  - requirements.txt
autonomous: true
user_setup:
  - service: google-cloud-storage
    why: "GCS attachment storage"
    env_vars:
      - name: GOOGLE_APPLICATION_CREDENTIALS
        source: "GCP Console -> IAM -> Service Accounts -> Create Key (JSON)"
      - name: GCS_BUCKET_NAME
        source: "GCP Console -> Cloud Storage -> Bucket name"

must_haves:
  truths:
    - "Attachments download from GCS URLs to temp files"
    - "Temp files automatically cleaned up after processing"
    - "File format correctly detected from content and extension"
    - "Scanned PDFs detected via text-to-filesize ratio"
  artifacts:
    - path: "app/services/storage/gcs_client.py"
      provides: "GCS download with streaming and cleanup"
      contains: "class GCSAttachmentHandler"
    - path: "app/services/extraction/detector.py"
      provides: "File format and scanned PDF detection"
      contains: "def is_scanned_pdf"
  key_links:
    - from: "app/services/storage/gcs_client.py"
      to: "google.cloud.storage"
      via: "GCS Python client"
      pattern: "storage\\.Client"
    - from: "app/services/extraction/detector.py"
      to: "fitz"
      via: "PyMuPDF for scanned detection"
      pattern: "fitz\\.open"
---

<objective>
Create GCS storage client for attachment downloads and format detection for routing to appropriate extractors.

Purpose: Enables downloading attachments from Zendesk URLs (stored in GCS) with automatic temp file cleanup, and detects whether PDFs need PyMuPDF or Claude Vision processing.

Output: GCS client with context manager pattern, format detector with scanned PDF detection.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-multi-format-document-extraction/03-CONTEXT.md
@.planning/phases/03-multi-format-document-extraction/03-RESEARCH.md

# Attachment URL structure
@app/models/incoming_email.py
@app/models/webhook_schemas.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GCS attachment handler with streaming and cleanup</name>
  <files>
app/services/storage/__init__.py
app/services/storage/gcs_client.py
app/config.py
requirements.txt
  </files>
  <action>
Create GCS client for downloading attachments with automatic temp file cleanup.

**1. Add to requirements.txt:**
```
google-cloud-storage>=2.18.0
```

**2. Update app/config.py** - Add GCS settings:
```python
# GCS Storage (Phase 3)
gcs_bucket_name: Optional[str] = None
gcs_max_file_size_mb: int = 32  # Claude API 32MB limit
```

**3. Create app/services/storage/__init__.py:**
```python
from .gcs_client import GCSAttachmentHandler, FileTooLargeError

__all__ = ["GCSAttachmentHandler", "FileTooLargeError"]
```

**4. Create app/services/storage/gcs_client.py:**

**Exceptions:**
- `FileTooLargeError(Exception)` - File exceeds size limit

**GCSAttachmentHandler class:**
- `__init__(bucket_name: str = None)` - Uses settings.gcs_bucket_name if not provided
- `_client: storage.Client` - Lazy initialized

**Methods:**

`download_attachment(gcs_url: str) -> ContextManager[str]`:
- Context manager that yields temp file path
- Supports both `gs://bucket/path` and HTTPS URLs
- Creates temp file with correct extension
- Downloads file to temp path
- Yields path for processing
- Deletes temp file in finally block (even on exception)

`download_from_url(url: str) -> ContextManager[str]`:
- For HTTPS URLs (Zendesk attachment URLs)
- Uses httpx for download
- Same temp file + cleanup pattern

`download_with_size_check(url: str, max_size_mb: int = None) -> ContextManager[str]`:
- Checks file size before download
- Raises FileTooLargeError if exceeds limit
- For GCS: uses blob.size property
- For HTTPS: uses HEAD request Content-Length

**Implementation pattern:**
```python
from contextlib import contextmanager
import tempfile
import os

@contextmanager
def download_attachment(self, url: str):
    """Download file, yield path, auto-cleanup."""
    _, ext = os.path.splitext(url.split('?')[0])  # Handle query params
    fd, temp_path = tempfile.mkstemp(suffix=ext)
    os.close(fd)

    try:
        # Download logic here
        yield temp_path
    finally:
        if os.path.exists(temp_path):
            os.unlink(temp_path)
```

**Logging:**
- Log download start with URL (truncated for privacy)
- Log file size after download
- Log cleanup completion
- Use structlog
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.storage import GCSAttachmentHandler, FileTooLargeError
handler = GCSAttachmentHandler()
print('GCSAttachmentHandler import OK')
print(f'FileTooLargeError: {FileTooLargeError}')
"
```
  </verify>
  <done>GCSAttachmentHandler downloads from GCS/HTTPS URLs with context manager pattern, temp files auto-cleanup on exit</done>
</task>

<task type="auto">
  <name>Task 2: Create format detector with scanned PDF detection</name>
  <files>
app/services/extraction/__init__.py
app/services/extraction/detector.py
requirements.txt
  </files>
  <action>
Create file format detection and scanned PDF detection logic.

**1. Add to requirements.txt:**
```
PyMuPDF>=1.24.0
```

**2. Create app/services/extraction/__init__.py:**
```python
from .detector import (
    detect_file_format,
    is_scanned_pdf,
    FileFormat,
    SUPPORTED_FORMATS
)

__all__ = [
    "detect_file_format",
    "is_scanned_pdf",
    "FileFormat",
    "SUPPORTED_FORMATS"
]
```

**3. Create app/services/extraction/detector.py:**

**Constants:**
```python
from enum import Enum

class FileFormat(str, Enum):
    PDF = "pdf"
    DOCX = "docx"
    XLSX = "xlsx"
    IMAGE_JPG = "image_jpg"
    IMAGE_PNG = "image_png"
    UNKNOWN = "unknown"

SUPPORTED_FORMATS = {FileFormat.PDF, FileFormat.DOCX, FileFormat.XLSX, FileFormat.IMAGE_JPG, FileFormat.IMAGE_PNG}

EXTENSION_MAP = {
    ".pdf": FileFormat.PDF,
    ".docx": FileFormat.DOCX,
    ".xlsx": FileFormat.XLSX,
    ".jpg": FileFormat.IMAGE_JPG,
    ".jpeg": FileFormat.IMAGE_JPG,
    ".png": FileFormat.IMAGE_PNG,
}

MIME_TYPE_MAP = {
    "application/pdf": FileFormat.PDF,
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": FileFormat.DOCX,
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": FileFormat.XLSX,
    "image/jpeg": FileFormat.IMAGE_JPG,
    "image/png": FileFormat.IMAGE_PNG,
}
```

**Functions:**

`detect_file_format(filename: str, content_type: Optional[str] = None) -> FileFormat`:
- First check content_type against MIME_TYPE_MAP
- Fall back to extension from filename
- Return FileFormat.UNKNOWN if not recognized

`is_scanned_pdf(pdf_path: str, threshold: float = 0.01) -> bool`:
- Open PDF with PyMuPDF (fitz)
- Extract all text from all pages
- Calculate text_length / file_size ratio
- If ratio < threshold: likely scanned (return True)
- Handle encrypted PDFs: return True (needs Claude Vision)
- Log detection result

`is_encrypted_pdf(pdf_path: str) -> bool`:
- Try to open with fitz
- Check doc.is_encrypted property
- Return True if encrypted

`get_pdf_page_count(pdf_path: str) -> int`:
- Open with fitz, return len(doc)
- Handle errors gracefully

**Error handling:**
- Wrap fitz.open in try/except
- Log errors but don't raise (return safe defaults)
- Encrypted PDFs should not crash the system

**Implementation notes:**
- Use `fitz.open(pdf_path)` not `fitz.Document`
- Always close document after use: `doc.close()`
- For scanned detection, sample first 5 pages if doc is large (performance)
  </action>
  <verify>
```bash
cd "/Users/luka.s/NEW AI Creditor Answer Analysis"
python -c "
from app.services.extraction import detect_file_format, is_scanned_pdf, FileFormat
assert detect_file_format('invoice.pdf') == FileFormat.PDF
assert detect_file_format('data.xlsx', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet') == FileFormat.XLSX
print('Format detection OK')
"
# Test PyMuPDF import
python -c "import fitz; print(f'PyMuPDF version: {fitz.version}')"
```
  </verify>
  <done>Format detector correctly identifies PDF, DOCX, XLSX, JPG, PNG; scanned PDF detection uses text-to-filesize ratio with 0.01 threshold</done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `pip install -r requirements.txt` includes google-cloud-storage and PyMuPDF
2. GCSAttachmentHandler context manager pattern works
3. Format detection correctly maps extensions and MIME types
4. PyMuPDF imports successfully for scanned detection
</verification>

<success_criteria>
- GCS downloads work with both gs:// and HTTPS URLs
- Temp files automatically cleaned up after context exits
- File format correctly detected from extension and MIME type
- Scanned PDF detection available for routing decisions
</success_criteria>

<output>
After completion, create `.planning/phases/03-multi-format-document-extraction/03-02-SUMMARY.md`
</output>
