---
phase: 04-german-document-extraction
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/extraction/german_parser.py
  - requirements.txt
  - tests/test_german_parser.py
autonomous: true

must_haves:
  truths:
    - "German format '1.234,56 EUR' parses to 1234.56"
    - "US format '1,234.56 EUR' parses correctly as fallback"
    - "Ambiguous format '1.234 EUR' parses as German (1234.0)"
    - "Currency symbols (EUR, Euro sign) are stripped correctly"
    - "Invalid amount strings raise ValueError"
  artifacts:
    - path: "app/services/extraction/german_parser.py"
      provides: "parse_german_amount function"
      exports: ["parse_german_amount"]
  key_links:
    - from: "app/services/extraction/german_parser.py"
      to: "babel.numbers"
      via: "parse_decimal with locale"
      pattern: "parse_decimal.*locale.*de_DE"
---

<objective>
Create locale-aware German amount parser using babel library.

Purpose: German amounts (1.234,56 EUR) must parse correctly without confusion with US format (1,234.56). USER DECISION: Try German format first, fall back to US format, accept whichever parses.

Output: parse_german_amount() function that reliably parses German and US currency formats.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-german-document-extraction/04-CONTEXT.md
@.planning/phases/04-german-document-extraction/04-RESEARCH.md
@app/services/extraction/email_body_extractor.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add babel dependency to requirements.txt</name>
  <files>
    requirements.txt
  </files>
  <action>
Update requirements.txt to add babel for locale-aware number parsing.

Add after the pyspellchecker line (or after Pillow if pyspellchecker not yet added):
```
# German Text Processing (Phase 4)
babel>=2.17.0
```

Note: If pyspellchecker was added by Plan 01, place babel in the same Phase 4 section.
If Plan 01 hasn't run yet, create the Phase 4 section header and add babel.
  </action>
  <verify>
grep -q "babel" "/Users/luka.s/NEW AI Creditor Answer Analysis/requirements.txt" && echo "babel found" || echo "babel missing"
  </verify>
  <done>
babel>=2.17.0 added to requirements.txt in Phase 4 section.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create German amount parser with babel</name>
  <files>
    app/services/extraction/german_parser.py
  </files>
  <action>
Create `app/services/extraction/german_parser.py` with parse_german_amount function:

```python
"""
German Amount Parser (Phase 4: German Document Extraction)

Parses monetary amounts using German locale (de_DE) with US fallback.

USER DECISION: Try German format first (1.234,56), fall back to US (1,234.56),
accept whichever parses successfully.
"""

import re
from typing import Optional
from decimal import Decimal

import structlog

try:
    from babel.numbers import parse_decimal, NumberFormatError
except ImportError:
    parse_decimal = None
    NumberFormatError = ValueError

logger = structlog.get_logger(__name__)


def parse_german_amount(amount_str: str) -> float:
    """
    Parse German-format monetary amount with US format fallback.

    Args:
        amount_str: Amount string like "1.234,56 EUR", "EUR 1,234.56", "1234.56"

    Returns:
        Parsed float value (e.g., 1234.56)

    Raises:
        ValueError: If amount cannot be parsed in either format

    Examples:
        >>> parse_german_amount("1.234,56 EUR")
        1234.56
        >>> parse_german_amount("1,234.56 EUR")
        1234.56
        >>> parse_german_amount("2.500 EUR")
        2500.0
    """
    if parse_decimal is None:
        raise ImportError("babel package required. Install with: pip install babel")

    # Clean amount string: remove currency symbols and extra whitespace
    cleaned = amount_str.strip()
    cleaned = re.sub(r'\s*(EUR|Euro|\u20ac)\s*', '', cleaned, flags=re.IGNORECASE)
    cleaned = cleaned.strip()

    if not cleaned:
        raise ValueError(f"Empty amount after cleaning: {amount_str}")

    log = logger.bind(original=amount_str, cleaned=cleaned)

    # Try German locale first (USER DECISION)
    try:
        result = float(parse_decimal(cleaned, locale='de_DE'))
        log.debug("amount_parsed", locale="de_DE", result=result)
        return result
    except (NumberFormatError, ValueError) as e:
        log.debug("german_parse_failed", error=str(e))

    # Fallback to US locale
    try:
        result = float(parse_decimal(cleaned, locale='en_US'))
        log.debug("amount_parsed", locale="en_US", result=result)
        return result
    except (NumberFormatError, ValueError) as e:
        log.debug("us_parse_failed", error=str(e))

    # Both failed - raise with helpful message
    raise ValueError(
        f"Cannot parse amount '{amount_str}' (cleaned: '{cleaned}') "
        f"as German (de_DE) or US (en_US) format"
    )


def extract_amount_from_text(text: str) -> Optional[float]:
    """
    Extract first monetary amount from text string.

    Searches for patterns like "1.234,56 EUR", "EUR 1234.56", "1234,56 Euro".

    Args:
        text: Text potentially containing a monetary amount

    Returns:
        Parsed amount as float, or None if no amount found

    Examples:
        >>> extract_amount_from_text("Die Gesamtforderung betraegt 1.234,56 EUR")
        1234.56
        >>> extract_amount_from_text("No amount here")
        None
    """
    # Pattern to find amount with optional currency
    amount_pattern = r'(\d{1,3}(?:[.,]\d{3})*(?:[.,]\d{1,2})?)\s*(?:EUR|Euro|\u20ac)?|(?:EUR|Euro|\u20ac)\s*(\d{1,3}(?:[.,]\d{3})*(?:[.,]\d{1,2})?)'

    match = re.search(amount_pattern, text, re.IGNORECASE)
    if not match:
        return None

    # Get the matched amount (could be in group 1 or 2)
    amount_str = match.group(1) or match.group(2)
    if not amount_str:
        return None

    try:
        return parse_german_amount(amount_str)
    except ValueError:
        return None


__all__ = ["parse_german_amount", "extract_amount_from_text"]
```

Key behaviors:
1. Cleans currency symbols (EUR, Euro, Euro sign) before parsing
2. Tries German locale first (de_DE)
3. Falls back to US locale (en_US) if German fails
4. Raises ValueError with helpful message if both fail
5. extract_amount_from_text() helper for regex-based extraction
  </action>
  <verify>
python -c "from app.services.extraction.german_parser import parse_german_amount; print(parse_german_amount('1.234,56 EUR'))"
  </verify>
  <done>
parse_german_amount() function parses German format amounts correctly with US fallback. babel library used for robust locale handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for German amount parser</name>
  <files>
    tests/test_german_parser.py
  </files>
  <action>
Create `tests/test_german_parser.py` with comprehensive tests:

```python
"""Tests for German amount parser."""

import pytest
from app.services.extraction.german_parser import parse_german_amount, extract_amount_from_text


class TestParseGermanAmount:
    """Tests for parse_german_amount function."""

    def test_german_format_with_decimals(self):
        """1.234,56 EUR should parse to 1234.56"""
        assert parse_german_amount("1.234,56 EUR") == 1234.56

    def test_german_format_thousands_only(self):
        """2.500 EUR (German thousands separator) should parse to 2500.0"""
        assert parse_german_amount("2.500 EUR") == 2500.0

    def test_german_format_no_thousands(self):
        """234,56 EUR should parse to 234.56"""
        assert parse_german_amount("234,56 EUR") == 234.56

    def test_us_format_fallback(self):
        """1,234.56 EUR (US format) should parse via fallback"""
        result = parse_german_amount("1,234.56 EUR")
        assert result == 1234.56

    def test_us_format_thousands_only(self):
        """2,500 EUR (US format) should parse via fallback"""
        # Note: This is ambiguous - could be German 2.5 or US 2500
        # German locale tries first: 2,500 in de_DE = 2.5
        # If we want 2500, we need to detect the pattern
        result = parse_german_amount("2,500 EUR")
        # Accept either interpretation based on babel's behavior
        assert result in [2.5, 2500.0]

    def test_euro_sign_currency(self):
        """Amount with Euro sign should work"""
        assert parse_german_amount("1.234,56 \u20ac") == 1234.56

    def test_currency_before_amount(self):
        """EUR 1.234,56 should work"""
        assert parse_german_amount("EUR 1.234,56") == 1234.56

    def test_simple_integer(self):
        """Simple integer amount"""
        assert parse_german_amount("1234 EUR") == 1234.0

    def test_whitespace_handling(self):
        """Extra whitespace should be trimmed"""
        assert parse_german_amount("  1.234,56 EUR  ") == 1234.56

    def test_invalid_amount_raises(self):
        """Invalid amount should raise ValueError"""
        with pytest.raises(ValueError):
            parse_german_amount("not an amount")

    def test_empty_string_raises(self):
        """Empty string should raise ValueError"""
        with pytest.raises(ValueError):
            parse_german_amount("")

    def test_large_amount(self):
        """Large German format amount"""
        assert parse_german_amount("123.456.789,12 EUR") == 123456789.12


class TestExtractAmountFromText:
    """Tests for extract_amount_from_text function."""

    def test_extract_from_sentence(self):
        """Extract amount from German sentence"""
        text = "Die Gesamtforderung betraegt 1.234,56 EUR."
        assert extract_amount_from_text(text) == 1234.56

    def test_extract_with_euro_symbol(self):
        """Extract amount with Euro symbol"""
        text = "Betrag: 500,00 \u20ac"
        assert extract_amount_from_text(text) == 500.0

    def test_no_amount_returns_none(self):
        """No amount in text returns None"""
        assert extract_amount_from_text("No amounts here") is None

    def test_extract_first_amount(self):
        """Extracts first amount when multiple present"""
        text = "Hauptforderung 1.000 EUR, Zinsen 234,56 EUR"
        result = extract_amount_from_text(text)
        assert result == 1000.0  # First match
```

Run tests to verify all pass.
  </action>
  <verify>
cd "/Users/luka.s/NEW AI Creditor Answer Analysis" && python -m pytest tests/test_german_parser.py -v
  </verify>
  <done>
All tests pass. parse_german_amount handles German and US formats correctly. extract_amount_from_text finds amounts in text.
  </done>
</task>

</tasks>

<verification>
1. Run: `pip install babel>=2.17.0` (or pip install -r requirements.txt)
2. Run: `python -c "from app.services.extraction.german_parser import parse_german_amount; print(parse_german_amount('1.234,56 EUR'))"`
3. Run: `python -m pytest tests/test_german_parser.py -v`
4. Verify babel in requirements.txt
</verification>

<success_criteria>
- parse_german_amount("1.234,56 EUR") returns 1234.56
- parse_german_amount("1,234.56 EUR") returns 1234.56 (US fallback)
- Invalid amounts raise ValueError with helpful message
- extract_amount_from_text() finds amounts in German text
- babel>=2.17.0 in requirements.txt
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-german-document-extraction/04-02-SUMMARY.md`
</output>
