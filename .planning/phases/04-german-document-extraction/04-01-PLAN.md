---
phase: 04-german-document-extraction
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/services/extraction/german_preprocessor.py
  - app/services/extraction/german_validator.py
  - tests/test_german_preprocessor.py
autonomous: true

must_haves:
  truths:
    - "Text with decomposed Umlauts normalizes to composed form"
    - "OCR errors like 'Muller' correct to 'Mueller' when dictionary validates"
    - "Legitimate words like 'Feuer' remain unchanged"
    - "German postal codes validate as 5 digits exactly"
    - "German names with Umlauts pass validation"
  artifacts:
    - path: "app/services/extraction/german_preprocessor.py"
      provides: "GermanTextPreprocessor class with preprocess() method"
      exports: ["GermanTextPreprocessor"]
    - path: "app/services/extraction/german_validator.py"
      provides: "GermanValidator class with validate_* methods"
      exports: ["GermanValidator"]
  key_links:
    - from: "app/services/extraction/german_preprocessor.py"
      to: "unicodedata"
      via: "normalize('NFKC', text)"
      pattern: "unicodedata\\.normalize.*NFKC"
    - from: "app/services/extraction/german_preprocessor.py"
      to: "pyspellchecker"
      via: "SpellChecker(language='de')"
      pattern: "SpellChecker.*language.*de"
---

<objective>
Create German text preprocessing and validation layer for extraction pipeline.

Purpose: German text must be normalized (Unicode NFKC) and optionally OCR-corrected before extraction to ensure consistent matching and parsing. Validation catches malformed German formats before database storage.

Output: GermanTextPreprocessor class and GermanValidator class ready for integration into extractors.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-german-document-extraction/04-CONTEXT.md
@.planning/phases/04-german-document-extraction/04-RESEARCH.md
@app/services/extraction/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create GermanTextPreprocessor with Unicode normalization and OCR correction</name>
  <files>
    app/services/extraction/german_preprocessor.py
    requirements.txt
  </files>
  <action>
Create `app/services/extraction/german_preprocessor.py` with GermanTextPreprocessor class:

1. Import unicodedata (stdlib) and SpellChecker from pyspellchecker
2. Implement preprocess(text: str) -> str method:
   - Step 1: Apply unicodedata.normalize('NFKC', text) for consistent Umlaut representation
   - Step 2: Apply OCR error correction (conservative, dictionary-validated only)
3. Implement _correct_ocr_errors(text: str) -> str:
   - Split text into words
   - For each word, check if it contains common OCR-corrupted umlaut patterns
   - Try restoring actual Umlauts using the substitution map below
   - Only accept correction if result exists in German dictionary (SpellChecker)
   - USER DECISION: Better to miss correction than introduce errors
   - Log corrections at INFO level, skipped corrections at DEBUG level

4. Add OCR umlaut restoration map (correcting OCR-corrupted digraphs to actual Umlauts):
   ```python
   # OCR often loses umlauts, producing digraph spellings like "Mueller" or "Muller"
   # This map restores actual umlaut characters when dictionary validates
   umlaut_restorations = {
       'ue': 'u',  # Mueller -> Muller (with actual umlaut u)
       'oe': 'o',  # Goethe -> Gothe (with actual umlaut o)
       'ae': 'a',  # Baecker -> Backer (with actual umlaut a)
   }
   ```

   Implementation approach:
   - For a word like "Mueller", try replacing "ue" with "u" (u with umlaut)
   - Check if "Muller" (with umlaut) is in dictionary
   - If yes, return the umlaut version; if no, keep original "Mueller"
   - This honors user decision: "correct Muller to Mueller" means Muller -> Muller

5. USER DECISION: Apply character substitutions (3->e, 0->o, 1->l) ONLY to name/address fields via separate method correct_name_field(text: str) -> str. Do NOT apply to amounts or reference numbers.

Update requirements.txt: Add `pyspellchecker>=0.8.4` after Pillow line (in Phase 4 section).

Use structlog for logging, matching project patterns.
  </action>
  <verify>
python -c "from app.services.extraction.german_preprocessor import GermanTextPreprocessor; p = GermanTextPreprocessor(); print(p.preprocess('Mueller'))"
  </verify>
  <done>
GermanTextPreprocessor class exists with preprocess() method. Unicode normalization works. OCR correction restores actual Umlauts (ue->u, oe->o, ae->a) when dictionary validates. pyspellchecker added to requirements.txt.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create GermanValidator with postal code, name, and address validation</name>
  <files>
    app/services/extraction/german_validator.py
  </files>
  <action>
Create `app/services/extraction/german_validator.py` with GermanValidator class:

1. Define regex patterns as class constants:
   ```python
   # German postal code: exactly 5 digits
   POSTAL_CODE_PATTERN = r'^\d{5}$'

   # German name: allows Umlauts, hyphens, spaces, noble prefixes (von, zu, etc)
   NAME_PATTERN = r'^[A-Za-z\u00e4\u00f6\u00fc\u00c4\u00d6\u00dc\u00df\-\s]+(von|zu|vom|zum|zur|der)?\s*[A-Za-z\u00e4\u00f6\u00fc\u00c4\u00d6\u00dc\u00df\-\s]*$'

   # German street address: street name + house number + optional apartment
   ADDRESS_PATTERN = r'^[A-Za-z\u00e4\u00f6\u00fc\u00c4\u00d6\u00dc\u00df\.\-\s]+\s+\d+[a-z]?(\s*//.+)?$'
   ```

2. Implement validate_postal_code(code: str) -> bool:
   - Return True if matches POSTAL_CODE_PATTERN
   - Strip whitespace before checking

3. Implement validate_name(name: str) -> bool:
   - Return True if matches NAME_PATTERN (case-insensitive)
   - Strip whitespace before checking
   - Minimum length 2 characters

4. Implement validate_street_address(address: str) -> bool:
   - Return True if matches ADDRESS_PATTERN (case-insensitive)
   - Strip whitespace before checking

5. Add is_valid_german_format(value: str, field_type: str) -> bool dispatcher:
   - Routes to appropriate validator based on field_type ('postal_code', 'name', 'address')
   - Returns True for unknown field_type (permissive by default)

Use re.IGNORECASE for name and address patterns. Use Unicode escapes for Umlauts to ensure portability.
  </action>
  <verify>
python -c "from app.services.extraction.german_validator import GermanValidator; v = GermanValidator(); print(v.validate_postal_code('12345'), v.validate_name('Mueller'), v.validate_name('von Goethe'))"
  </verify>
  <done>
GermanValidator class exists with validate_postal_code(), validate_name(), validate_street_address() methods. All methods handle German characters correctly.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for preprocessor and validator</name>
  <files>
    tests/test_german_preprocessor.py
  </files>
  <action>
Create `tests/test_german_preprocessor.py` with pytest tests:

1. Test GermanTextPreprocessor:
   ```python
   class TestGermanTextPreprocessor:
       def test_unicode_normalization_composed_unchanged(self):
           # Already composed Umlaut stays same
           assert preprocessor.preprocess("Muller") == "Muller"  # umlaut u stays

       def test_unicode_normalization_decomposed_to_composed(self):
           # Decomposed Umlaut (u + combining diaeresis) becomes composed
           decomposed = "Mu\u0308ller"  # u + combining umlaut
           result = preprocessor.preprocess(decomposed)
           assert "u\u0308" not in result  # No decomposed form

       def test_ocr_correction_mueller_to_umlaut(self):
           # "Mueller" (digraph) should become "Muller" (with umlaut u) if in dictionary
           result = preprocessor.preprocess("Mueller")
           # Result may be "Muller" (umlaut) or stay "Mueller" depending on dictionary
           assert result in ["Mueller", "Muller"]  # Second has actual umlaut

       def test_legitimate_words_unchanged(self):
           # "Feuer" should NOT become "Fer" (with umlaut) - that's not a word
           assert preprocessor.preprocess("Feuer") == "Feuer"

       def test_name_field_digit_correction(self):
           # Only in name field, not general text
           result = preprocessor.correct_name_field("M3yer")
           # Should attempt to correct 3->e
   ```

2. Test GermanValidator:
   ```python
   class TestGermanValidator:
       def test_postal_code_valid_5_digits(self):
           assert validator.validate_postal_code("12345") == True
           assert validator.validate_postal_code("01234") == True  # Leading zero

       def test_postal_code_invalid_4_digits(self):
           assert validator.validate_postal_code("1234") == False

       def test_postal_code_invalid_6_digits(self):
           assert validator.validate_postal_code("123456") == False

       def test_name_valid_simple(self):
           assert validator.validate_name("Mueller") == True

       def test_name_valid_with_umlaut(self):
           assert validator.validate_name("Muller") == True  # actual umlaut

       def test_name_valid_with_prefix(self):
           assert validator.validate_name("von Goethe") == True

       def test_name_invalid_with_digits(self):
           assert validator.validate_name("Mueller123") == False

       def test_address_valid_simple(self):
           assert validator.validate_street_address("Hauptstrasse 15") == True

       def test_address_valid_with_letter(self):
           assert validator.validate_street_address("Am Ring 3a") == True
   ```

Run tests to verify all pass.
  </action>
  <verify>
cd "/Users/luka.s/NEW AI Creditor Answer Analysis" && python -m pytest tests/test_german_preprocessor.py -v
  </verify>
  <done>
All tests pass. GermanTextPreprocessor and GermanValidator work correctly for German text patterns.
  </done>
</task>

</tasks>

<verification>
1. Run: `python -c "from app.services.extraction.german_preprocessor import GermanTextPreprocessor"`
2. Run: `python -c "from app.services.extraction.german_validator import GermanValidator"`
3. Run: `python -m pytest tests/test_german_preprocessor.py -v`
4. Verify pyspellchecker in requirements.txt
</verification>

<success_criteria>
- GermanTextPreprocessor.preprocess() normalizes Unicode and restores Umlauts from digraphs (ue->u, oe->o, ae->a)
- GermanTextPreprocessor.correct_name_field() handles digit->letter substitutions in names only
- GermanValidator validates German postal codes (5 digits)
- GermanValidator validates German names (with Umlauts, prefixes)
- GermanValidator validates German addresses (street + number format)
- All unit tests pass
- pyspellchecker>=0.8.4 added to requirements.txt
</success_criteria>

<output>
After completion, create `.planning/phases/04-german-document-extraction/04-01-SUMMARY.md`
</output>
