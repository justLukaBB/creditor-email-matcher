---
phase: 05-multi-agent-pipeline-validation
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/services/validation/conflict_detector.py
  - app/actors/consolidation_agent.py
  - app/actors/__init__.py
  - app/services/validation/__init__.py
autonomous: true

must_haves:
  truths:
    - "Agent 3 merges extraction results using majority voting for conflicts"
    - "Conflict detection flags when new data contradicts existing database records by >10%"
    - "Checkpoint saved with final_amount, conflicts_detected, and validation_status"
    - "needs_review flag set when conflicts detected or confidence < 0.7"
  artifacts:
    - path: "app/services/validation/conflict_detector.py"
      provides: "Database conflict detection"
      exports: ["detect_database_conflicts"]
    - path: "app/actors/consolidation_agent.py"
      provides: "Agent 3 Dramatiq actor"
      exports: ["consolidate_results"]
  key_links:
    - from: "app/actors/consolidation_agent.py"
      to: "app/services/extraction/consolidator.py"
      via: "ExtractionConsolidator reuse"
      pattern: "ExtractionConsolidator"
    - from: "app/actors/consolidation_agent.py"
      to: "app/services/validation/conflict_detector.py"
      via: "Database conflict check"
      pattern: "detect_database_conflicts"
---

<objective>
Implement Agent 3 (Consolidation): merge extraction results from all sources, resolve conflicts using majority voting, detect conflicts with existing database records, and compute final confidence.

Purpose: Produce final validated extraction result with conflict detection and needs_review flagging.
Output: Conflict detector service and consolidation Dramatiq actor.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-CONTEXT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-RESEARCH.md

@app/services/extraction/consolidator.py
@app/services/validation/checkpoint.py
@app/models/extraction_result.py
@app/services/mongodb_client.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conflict detector service</name>
  <files>
    app/services/validation/conflict_detector.py
    app/services/validation/__init__.py
  </files>
  <action>
1. Create app/services/validation/conflict_detector.py:
   ```python
   """
   Conflict Detector (Phase 5: Multi-Agent Pipeline)

   Detects conflicts between newly extracted data and existing database records.
   USER DECISION: Trust new extraction, overwrite existing (latest email is source of truth).
   """

   import structlog
   from typing import Dict, Any, List, Optional

   logger = structlog.get_logger()


   def detect_database_conflicts(
       extracted_data: Dict[str, Any],
       existing_data: Optional[Dict[str, Any]]
   ) -> List[Dict[str, Any]]:
       """
       Detect conflicts between extracted and existing data.

       Conflict threshold: >10% difference for amounts (USER DISCRETION).

       Args:
           extracted_data: Newly extracted data with gesamtforderung, client_name, creditor_name
           existing_data: Existing database record (from MongoDB final_creditor_list)

       Returns:
           List of conflict dicts: [{"type": "amount_mismatch", "old_value": ..., "new_value": ..., "difference_percent": ...}]
       """
       conflicts = []

       if not existing_data:
           return conflicts

       # Amount conflict detection
       new_amount = extracted_data.get("gesamtforderung")
       old_amount = existing_data.get("debt_amount") or existing_data.get("gesamtforderung")

       if new_amount and old_amount and old_amount > 0:
           difference = abs(new_amount - old_amount)
           difference_percent = (difference / old_amount) * 100

           # Conflict if >10% difference (USER DISCRETION)
           if difference_percent > 10:
               conflict = {
                   "type": "amount_mismatch",
                   "field": "gesamtforderung",
                   "old_value": old_amount,
                   "new_value": new_amount,
                   "difference_percent": round(difference_percent, 2)
               }
               conflicts.append(conflict)

               logger.warning("conflict_detected",
                   type="amount_mismatch",
                   old_value=old_amount,
                   new_value=new_amount,
                   difference_percent=difference_percent)

       # Name conflict detection (different names entirely)
       new_client = extracted_data.get("client_name")
       old_client = existing_data.get("client_name")
       if new_client and old_client and new_client.lower() != old_client.lower():
           # Check for partial match (substring)
           if new_client.lower() not in old_client.lower() and old_client.lower() not in new_client.lower():
               conflicts.append({
                   "type": "client_name_mismatch",
                   "field": "client_name",
                   "old_value": old_client,
                   "new_value": new_client
               })

       return conflicts


   def resolve_conflict_by_majority(amounts: List[float]) -> tuple:
       """
       Resolve conflicting amounts using majority voting.
       Returns (winning_amount, confidence_score).

       USER DISCRETION: Majority voting shows strong positive correlation with accuracy.
       Source: Spotify engineering blog (2024)
       """
       if not amounts:
           return (100.0, 0.3)  # Default amount, LOW confidence

       if len(amounts) == 1:
           return (amounts[0], 0.9)  # Single source, HIGH confidence

       # Deduplicate within 1 EUR tolerance
       unique_amounts = []
       for amt in amounts:
           if not any(abs(amt - existing) < 1.0 for existing in unique_amounts):
               unique_amounts.append(amt)

       if len(unique_amounts) == 1:
           # All sources agree
           return (unique_amounts[0], 0.95)

       # Count votes for each unique amount
       votes = {amt: sum(1 for a in amounts if abs(a - amt) < 1.0) for amt in unique_amounts}
       winner = max(votes.keys(), key=lambda k: votes[k])
       vote_ratio = votes[winner] / len(amounts)

       # Confidence based on majority strength
       if vote_ratio >= 0.66:  # 2/3 majority
           confidence = 0.85
       elif vote_ratio >= 0.5:  # Simple majority
           confidence = 0.7
       else:  # Plurality (no clear winner)
           confidence = 0.5

       logger.info("conflict_resolved_by_majority",
           amounts=amounts,
           winner=winner,
           vote_ratio=vote_ratio,
           confidence=confidence)

       return (winner, confidence)
   ```

2. Update app/services/validation/__init__.py:
   - Add exports: detect_database_conflicts, resolve_conflict_by_majority
  </action>
  <verify>
    - `python -c "from app.services.validation import detect_database_conflicts, resolve_conflict_by_majority"`
    - `python -c "from app.services.validation.conflict_detector import detect_database_conflicts; print(detect_database_conflicts({'gesamtforderung': 1500}, {'debt_amount': 1000}))"`
    - Expected: [{"type": "amount_mismatch", "field": "gesamtforderung", "old_value": 1000, "new_value": 1500, "difference_percent": 50.0}]
  </verify>
  <done>
    - detect_database_conflicts flags >10% amount differences
    - detect_database_conflicts flags mismatched client names
    - resolve_conflict_by_majority uses voting for multiple sources
    - Functions exported from app.services.validation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Agent 3 consolidation actor</name>
  <files>
    app/actors/consolidation_agent.py
    app/actors/__init__.py
  </files>
  <action>
1. Create app/actors/consolidation_agent.py:
   ```python
   """
   Agent 3: Consolidation Actor

   Merges extraction results from all sources, resolves conflicts,
   detects conflicts with existing database records, computes final confidence.

   USER DECISIONS:
   - Trust new extraction, overwrite existing (latest email is source of truth)
   - Flag for review when conflicts detected or confidence < 0.7
   """

   import dramatiq
   import gc
   import structlog
   from typing import Dict, Any, List, Optional

   from app.actors import broker
   from app.database import SessionLocal
   from app.models import IncomingEmail
   from app.services.validation import (
       save_checkpoint,
       check_confidence_threshold,
       detect_database_conflicts,
       validate_with_partial_results,
   )
   from app.models.extraction_result import ConsolidatedExtractionResult

   logger = structlog.get_logger()


   @dramatiq.actor(
       broker=broker,
       queue_name="consolidation",
       max_retries=3,
       min_backoff=15000,
       max_backoff=300000,
   )
   def consolidate_results(extraction_result: Dict[str, Any]) -> Dict[str, Any]:
       """
       Agent 3: Consolidate extraction results and detect conflicts.

       Args:
           extraction_result: Dict from Agent 2 with extracted data

       Returns:
           Dict with final_amount, confidence, conflicts, needs_review
       """
       email_id = extraction_result.get("email_id")

       db = SessionLocal()
       try:
           # Load email for MongoDB data comparison
           email = db.query(IncomingEmail).filter(IncomingEmail.id == email_id).first()
           if not email:
               raise ValueError(f"Email {email_id} not found")

           # Get existing data from MongoDB for conflict detection
           existing_data = _get_existing_creditor_data(
               client_name=extraction_result.get("client_name"),
               creditor_email=email.from_email
           )

           # Detect conflicts with existing database records
           conflicts = detect_database_conflicts(extraction_result, existing_data)

           # Check confidence threshold
           confidence = extraction_result.get("confidence", 0.5)
           if isinstance(confidence, str):
               # Convert string confidence to float
               confidence_map = {"HIGH": 0.9, "MEDIUM": 0.7, "LOW": 0.5}
               confidence = confidence_map.get(confidence, 0.5)

           confidence_check = check_confidence_threshold(confidence)

           # Determine needs_review flag
           needs_review = (
               len(conflicts) > 0 or
               confidence_check["needs_review"] or
               extraction_result.get("needs_review", False)
           )

           # Build final result
           final_result = {
               "email_id": email_id,
               "final_amount": extraction_result.get("gesamtforderung"),
               "client_name": extraction_result.get("client_name"),
               "creditor_name": extraction_result.get("creditor_name"),
               "confidence": confidence,
               "conflicts_detected": len(conflicts),
               "conflicts": conflicts,
               "needs_review": needs_review,
               "sources_processed": extraction_result.get("sources_processed", 0),
           }

           # Validate final result schema (partial results OK)
           validation_result = validate_with_partial_results(final_result, dict)
           if validation_result["validation_errors"]:
               needs_review = True

           # Save checkpoint
           checkpoint_data = {
               "final_amount": final_result["final_amount"],
               "confidence": confidence,
               "conflicts_detected": len(conflicts),
               "conflicts": conflicts,
               "validation_status": "needs_review" if needs_review else "passed"
           }
           save_checkpoint(db, email_id, "agent_3_consolidation", checkpoint_data)

           logger.info("consolidation_complete",
               email_id=email_id,
               final_amount=final_result["final_amount"],
               confidence=confidence,
               conflicts=len(conflicts),
               needs_review=needs_review)

           return final_result

       finally:
           db.close()
           gc.collect()


   def _get_existing_creditor_data(
       client_name: Optional[str],
       creditor_email: Optional[str]
   ) -> Optional[Dict[str, Any]]:
       """
       Fetch existing creditor data from MongoDB for conflict detection.

       Returns:
           Dict with debt_amount, client_name if found, else None
       """
       if not client_name and not creditor_email:
           return None

       try:
           from app.services.mongodb_client import mongodb_service

           # Query MongoDB for existing client/creditor record
           # This is simplified - actual query depends on MongoDB schema
           db = mongodb_service.get_db()
           if db is None:
               return None

           clients_collection = db.clients

           # Find client by name (fuzzy match would be Phase 6)
           if client_name:
               client = clients_collection.find_one({
                   "name": {"$regex": client_name, "$options": "i"}
               })

               if client and "final_creditor_list" in client:
                   # Find creditor in list
                   for creditor in client.get("final_creditor_list", []):
                       if creditor_email and creditor.get("email", "").lower() == creditor_email.lower():
                           return {
                               "client_name": client.get("name"),
                               "debt_amount": creditor.get("debt_amount"),
                               "creditor_name": creditor.get("name")
                           }

           return None

       except Exception as e:
           logger.warning("mongodb_query_failed", error=str(e))
           return None
   ```

2. Update app/actors/__init__.py:
   - Add import for consolidate_results actor
  </action>
  <verify>
    - `python -c "from app.actors.consolidation_agent import consolidate_results"`
    - `python -c "from app.actors import consolidate_results"` (after __init__.py update)
  </verify>
  <done>
    - consolidate_results Dramatiq actor merges extraction data
    - Conflict detection against MongoDB existing records
    - Checkpoint saved with final_amount, conflicts, validation_status
    - needs_review flag set when conflicts detected or confidence < 0.7
    - REQ-PIPELINE-04, REQ-PIPELINE-08 addressed
  </done>
</task>

</tasks>

<verification>
Agent 3 (Consolidation) complete:
1. `python -c "from app.services.validation import detect_database_conflicts; c = detect_database_conflicts({'gesamtforderung': 1500}, {'debt_amount': 1000}); print(len(c), c[0]['type'])"`
   Expected: "1 amount_mismatch"
2. `python -c "from app.services.validation import resolve_conflict_by_majority; print(resolve_conflict_by_majority([1000, 1000, 1500]))"`
   Expected: "(1000, 0.85)" (2/3 majority)
3. `python -c "from app.actors.consolidation_agent import consolidate_results"`
</verification>

<success_criteria>
- detect_database_conflicts flags >10% amount differences
- resolve_conflict_by_majority returns winner with confidence based on voting strength
- consolidate_results actor merges extraction results
- Checkpoint saved with conflicts and validation status
- needs_review flag set for conflicts or low confidence
- REQ-PIPELINE-04 (Agent 3 consolidation) addressed
- REQ-PIPELINE-08 (conflict detection) addressed
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-agent-pipeline-validation/05-03-SUMMARY.md`
</output>
