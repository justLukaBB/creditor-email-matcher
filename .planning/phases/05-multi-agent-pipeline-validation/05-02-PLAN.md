---
phase: 05-multi-agent-pipeline-validation
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/services/intent_classifier.py
  - app/actors/intent_classifier.py
autonomous: true

must_haves:
  truths:
    - "Auto-reply emails detected via headers without Claude API call"
    - "Spam emails detected via noreply@ pattern without Claude API call"
    - "Ambiguous emails classified by Claude Haiku with intent + confidence"
    - "Intent classification saves checkpoint with timestamp and method"
  artifacts:
    - path: "app/services/intent_classifier.py"
      provides: "Rule-based + LLM fallback classification"
      exports: ["classify_intent_cheap", "classify_intent_with_llm", "classify_email_intent"]
    - path: "app/actors/intent_classifier.py"
      provides: "Dramatiq actor for Agent 1"
      exports: ["classify_intent"]
  key_links:
    - from: "app/services/intent_classifier.py"
      to: "email.message"
      via: "Header parsing"
      pattern: "Auto-Submitted|X-Auto-Response"
    - from: "app/actors/intent_classifier.py"
      to: "app/services/validation"
      via: "Checkpoint save"
      pattern: "save_checkpoint"
---

<objective>
Implement Agent 1 (Email Processing): intent classification using rule-based detection for cheap intents (auto-reply, spam) with Claude Haiku fallback for ambiguous emails.

Purpose: Route emails to appropriate extraction strategies and skip extraction entirely for auto-reply/spam (saving tokens).
Output: Intent classifier service and Dramatiq actor that classifies emails into 6 intent types.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-CONTEXT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-RESEARCH.md

@app/models/intent_classification.py
@app/services/validation/checkpoint.py
@app/actors/email_processor.py
@app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create intent classifier service</name>
  <files>
    app/services/intent_classifier.py
  </files>
  <action>
1. Create app/services/intent_classifier.py with three functions:

2. Implement `classify_intent_cheap(headers: dict, subject: str, body: str) -> Optional[IntentResult]`:
   ```python
   def classify_intent_cheap(headers: dict, subject: str, body: str) -> Optional[IntentResult]:
       """
       Rule-based classification for cheap intents.
       Returns None if ambiguous (requires LLM).

       USER DECISION: Skip extraction for auto_reply and spam.
       """
       # AUTO_REPLY detection via headers (RFC 5322 standard)
       auto_submitted = headers.get("Auto-Submitted", "no")
       if auto_submitted != "no":
           return IntentResult(
               intent=EmailIntent.auto_reply,
               confidence=0.95,
               method="header_auto_submitted",
               skip_extraction=True
           )

       # Microsoft Exchange OOO detection
       x_auto_response = headers.get("X-Auto-Response-Suppress", "")
       if any(flag in x_auto_response for flag in ["DR", "AutoReply", "All"]):
           return IntentResult(
               intent=EmailIntent.auto_reply,
               confidence=0.95,
               method="header_x_auto_response",
               skip_extraction=True
           )

       # Subject line patterns for OOO (German and English)
       ooo_patterns = [
           r"Auto.?Reply",
           r"Out of Office",
           r"Abwesenheitsnotiz",
           r"Automatische Antwort",
           r"is out of the office",
       ]
       if any(re.search(p, subject, re.IGNORECASE) for p in ooo_patterns):
           return IntentResult(
               intent=EmailIntent.auto_reply,
               confidence=0.9,
               method="subject_regex",
               skip_extraction=True
           )

       # SPAM detection via noreply addresses
       from_email = headers.get("From", "")
       if re.search(r"^no.?reply@", from_email, re.IGNORECASE):
           return IntentResult(
               intent=EmailIntent.spam,
               confidence=0.85,
               method="noreply_address",
               skip_extraction=True
           )

       # Ambiguous - needs LLM
       return None
   ```

3. Implement `classify_intent_with_llm(body: str, subject: str) -> IntentResult`:
   ```python
   def classify_intent_with_llm(body: str, subject: str) -> IntentResult:
       """
       Claude Haiku classification for 6 intent types.
       USER DECISION: Default to debt_statement if ambiguous.
       """
       # Use Claude Haiku (cheapest, sufficient for classification)
       # Truncate body to 500 chars for token efficiency
       # Return structured JSON with intent and confidence
       # Default to debt_statement with confidence < 0.7 if ambiguous
   ```
   - Use anthropic client from app.config (like entity_extractor_claude.py)
   - Model: claude-3-haiku-20240307 (cheapest)
   - max_tokens: 100 (classification is short)
   - Prompt includes all 6 intent types with descriptions
   - German examples in prompt (USER DECISION from Phase 4)
   - Parse JSON response, handle malformed JSON gracefully
   - Default to debt_statement with confidence=0.6 on parsing error

4. Implement `classify_email_intent(email_id: int, headers: dict, subject: str, body: str) -> IntentResult`:
   - Wrapper that tries cheap classification first, falls back to LLM
   - Logs classification method and result
   - Returns IntentResult

5. Add imports: re, structlog, anthropic, IntentResult, EmailIntent from app.models.intent_classification
  </action>
  <verify>
    - `python -c "from app.services.intent_classifier import classify_intent_cheap, classify_intent_with_llm, classify_email_intent"`
    - `python -c "from app.services.intent_classifier import classify_intent_cheap; r = classify_intent_cheap({'Auto-Submitted': 'auto-replied'}, '', ''); print(r.intent, r.skip_extraction)"` shows "auto_reply True"
  </verify>
  <done>
    - classify_intent_cheap detects auto-reply via headers and subject patterns
    - classify_intent_cheap detects spam via noreply@ pattern
    - classify_intent_with_llm uses Claude Haiku for ambiguous emails
    - classify_email_intent orchestrates cheap + LLM fallback
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Agent 1 Dramatiq actor</name>
  <files>
    app/actors/intent_classifier.py
    app/actors/__init__.py
  </files>
  <action>
1. Create app/actors/intent_classifier.py:
   ```python
   """
   Agent 1: Intent Classification Actor

   Classifies email intent using rule-based + LLM fallback.
   Saves checkpoint to agent_checkpoints JSONB column.

   USER DECISIONS:
   - Skip extraction for auto_reply and spam intents
   - Default to debt_statement when ambiguous
   """

   import dramatiq
   import structlog
   from typing import Dict, Any

   from app.actors import broker
   from app.database import SessionLocal
   from app.models import IncomingEmail
   from app.models.intent_classification import IntentResult
   from app.services.intent_classifier import classify_email_intent
   from app.services.validation import save_checkpoint, check_confidence_threshold

   logger = structlog.get_logger()


   @dramatiq.actor(
       broker=broker,
       queue_name="intent_classification",
       max_retries=3,
       min_backoff=15000,
       max_backoff=300000,
   )
   def classify_intent(email_id: int) -> Dict[str, Any]:
       """
       Agent 1: Classify email intent.

       Args:
           email_id: IncomingEmail.id to classify

       Returns:
           Dict with email_id, intent, confidence, skip_extraction, needs_review
       """
       db = SessionLocal()
       try:
           # Load email
           email = db.query(IncomingEmail).filter(IncomingEmail.id == email_id).first()
           if not email:
               raise ValueError(f"Email {email_id} not found")

           # Parse headers from email metadata
           # Headers come from from_email and subject (Zendesk webhook doesn't provide full headers)
           # Simulate headers dict for cheap classification
           headers = {
               "From": email.from_email or "",
               "Subject": email.subject or "",
               # Auto-Submitted and X-Auto-Response-Suppress not available from Zendesk
               # Will rely on subject patterns and from address
           }

           # Classify intent
           result = classify_email_intent(
               email_id=email_id,
               headers=headers,
               subject=email.subject or "",
               body=email.cleaned_body or email.raw_body_text or ""
           )

           # Check confidence threshold (USER DECISION: 0.7)
           confidence_check = check_confidence_threshold(result.confidence)
           needs_review = confidence_check["needs_review"]

           # Save checkpoint
           checkpoint_data = {
               "intent": result.intent.value,
               "confidence": result.confidence,
               "method": result.method,
               "skip_extraction": result.skip_extraction,
               "validation_status": "needs_review" if needs_review else "passed"
           }
           save_checkpoint(db, email_id, "agent_1_intent", checkpoint_data)

           logger.info("intent_classified",
               email_id=email_id,
               intent=result.intent.value,
               confidence=result.confidence,
               method=result.method,
               skip_extraction=result.skip_extraction,
               needs_review=needs_review)

           return {
               "email_id": email_id,
               "intent": result.intent.value,
               "confidence": result.confidence,
               "method": result.method,
               "skip_extraction": result.skip_extraction,
               "needs_review": needs_review
           }

       finally:
           db.close()
   ```

2. Update app/actors/__init__.py:
   - Add import for classify_intent actor
   - Ensure broker is accessible

3. Note: The actor returns a dict that will be passed to Agent 2 via Dramatiq pipeline
  </action>
  <verify>
    - `python -c "from app.actors.intent_classifier import classify_intent"`
    - `python -c "from app.actors import classify_intent"` (after __init__.py update)
  </verify>
  <done>
    - classify_intent Dramatiq actor loads email and classifies intent
    - Checkpoint saved to IncomingEmail.agent_checkpoints
    - Returns dict with email_id, intent, confidence, skip_extraction, needs_review
    - Actor uses queue_name="intent_classification" for dedicated queue
  </done>
</task>

</tasks>

<verification>
Agent 1 (Intent Classification) complete:
1. `python -c "from app.services.intent_classifier import classify_intent_cheap; print(classify_intent_cheap({'Auto-Submitted': 'auto-replied'}, '', '').method)"` returns "header_auto_submitted"
2. `python -c "from app.services.intent_classifier import classify_intent_cheap; r = classify_intent_cheap({'From': 'noreply@test.com'}, '', ''); print(r.intent.value if r else 'None')"` returns "spam"
3. `python -c "from app.services.intent_classifier import classify_intent_cheap; print(classify_intent_cheap({}, 'Abwesenheitsnotiz', '').intent.value)"` returns "auto_reply"
4. `python -c "from app.actors.intent_classifier import classify_intent"`
</verification>

<success_criteria>
- Auto-reply detected via Auto-Submitted header, X-Auto-Response-Suppress header, or subject patterns
- Spam detected via noreply@ address pattern
- Claude Haiku used only for ambiguous emails (cost savings)
- Checkpoint saved with intent, confidence, method, timestamp
- Actor returns structured dict for pipeline chaining
- REQ-PIPELINE-01 and REQ-PIPELINE-02 addressed
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-agent-pipeline-validation/05-02-SUMMARY.md`
</output>
