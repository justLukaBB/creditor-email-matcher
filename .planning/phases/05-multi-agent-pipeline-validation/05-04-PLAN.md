---
phase: 05-multi-agent-pipeline-validation
plan: 04
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - app/models/manual_review.py
  - app/models/__init__.py
  - app/routers/manual_review.py
  - app/routers/__init__.py
  - app/main.py
  - alembic/versions/XXXX_add_manual_review_queue_table.py
autonomous: true

must_haves:
  truths:
    - "ManualReviewQueue table stores items flagged for human review"
    - "Items can be claimed by reviewer with FOR UPDATE SKIP LOCKED concurrency"
    - "API endpoint lists pending review items sorted by creation time"
    - "API endpoint allows claiming and resolving review items"
  artifacts:
    - path: "app/models/manual_review.py"
      provides: "ManualReviewQueue SQLAlchemy model"
      exports: ["ManualReviewQueue"]
    - path: "app/routers/manual_review.py"
      provides: "REST API for manual review queue"
      exports: ["router"]
  key_links:
    - from: "app/routers/manual_review.py"
      to: "app/models/manual_review.py"
      via: "SQLAlchemy queries"
      pattern: "ManualReviewQueue"
    - from: "app/routers/manual_review.py"
      to: "sqlalchemy"
      via: "FOR UPDATE SKIP LOCKED"
      pattern: "with_for_update.*skip_locked"
---

<objective>
Create manual review queue infrastructure: database model and REST API for surfacing items flagged with needs_review=True.

Purpose: Enable human reviewers to claim and resolve items with low confidence or detected conflicts.
Output: ManualReviewQueue model, Alembic migration, and REST API endpoints.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-CONTEXT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-RESEARCH.md

@app/models/incoming_email.py
@app/routers/jobs.py
@app/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ManualReviewQueue model and migration</name>
  <files>
    app/models/manual_review.py
    app/models/__init__.py
    alembic/versions/XXXX_add_manual_review_queue_table.py
  </files>
  <action>
1. Create app/models/manual_review.py:
   ```python
   """
   Manual Review Queue Model (Phase 5: Multi-Agent Pipeline)

   Stores items flagged for human review by validation layers.
   Reasons: low_confidence, validation_failure, conflict_detected

   Uses FOR UPDATE SKIP LOCKED pattern for concurrent claim safety.
   """

   from sqlalchemy import Column, Integer, String, DateTime, Text, ForeignKey
   from sqlalchemy.sql import func
   from app.database import Base


   class ManualReviewQueue(Base):
       """
       Queue for items needing manual review.

       Concurrency: Use FOR UPDATE SKIP LOCKED when claiming items
       to prevent race conditions between reviewers.
       """
       __tablename__ = "manual_review_queue"

       # Primary Key
       id = Column(Integer, primary_key=True, index=True)

       # Foreign key to incoming_emails
       email_id = Column(Integer, ForeignKey("incoming_emails.id"), nullable=False, index=True)

       # Review reason
       # Values: low_confidence, validation_failure, conflict_detected, extraction_error
       review_reason = Column(String(50), nullable=False)
       review_details = Column(Text, nullable=True)  # JSON string with conflict details, validation errors, etc.

       # Priority (higher = more urgent)
       # 1=low_confidence, 2=validation_failure, 3=conflict_detected
       priority = Column(Integer, default=1, nullable=False)

       # Claim tracking (FOR UPDATE SKIP LOCKED pattern)
       claimed_at = Column(DateTime(timezone=True), nullable=True)
       claimed_by = Column(String(100), nullable=True)  # Reviewer identifier

       # Resolution
       resolved_at = Column(DateTime(timezone=True), nullable=True)
       resolution = Column(String(50), nullable=True)  # approved, rejected, modified
       resolution_notes = Column(Text, nullable=True)

       # Timestamps
       created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
       updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())

       def __repr__(self):
           return f"<ManualReviewQueue(id={self.id}, email_id={self.email_id}, reason='{self.review_reason}', resolved={self.resolved_at is not None})>"
   ```

2. Update app/models/__init__.py:
   - Add import and export for ManualReviewQueue

3. Create Alembic migration:
   - Create manual_review_queue table with all columns
   - Add foreign key constraint to incoming_emails
   - Add index on (resolved_at, created_at) for efficient queue queries
   - Add index on claimed_by for reviewer lookup
  </action>
  <verify>
    - `python -c "from app.models.manual_review import ManualReviewQueue; print(ManualReviewQueue.__tablename__)"`
    - `python -c "from app.models import ManualReviewQueue"`
    - `alembic check` shows no pending migrations (after creating migration)
  </verify>
  <done>
    - ManualReviewQueue model with email_id, review_reason, priority, claim tracking, resolution
    - Foreign key to incoming_emails table
    - Exported from app.models
    - Alembic migration created
  </done>
</task>

<task type="auto">
  <name>Task 2: Create manual review API endpoints</name>
  <files>
    app/routers/manual_review.py
    app/routers/__init__.py
    app/main.py
  </files>
  <action>
1. Create app/routers/manual_review.py:
   ```python
   """
   Manual Review Queue API (Phase 5: Multi-Agent Pipeline)

   REST endpoints for listing, claiming, and resolving review items.
   Uses FOR UPDATE SKIP LOCKED for safe concurrent access.
   """

   from datetime import datetime
   from typing import List, Optional
   from fastapi import APIRouter, Depends, HTTPException
   from pydantic import BaseModel
   from sqlalchemy.orm import Session

   from app.database import get_db
   from app.models.manual_review import ManualReviewQueue
   from app.models import IncomingEmail

   router = APIRouter(prefix="/api/reviews", tags=["manual-review"])


   # Pydantic schemas
   class ReviewQueueItem(BaseModel):
       id: int
       email_id: int
       review_reason: str
       review_details: Optional[str]
       priority: int
       claimed_at: Optional[datetime]
       claimed_by: Optional[str]
       created_at: datetime

       class Config:
           from_attributes = True


   class ClaimRequest(BaseModel):
       reviewer_id: str


   class ResolveRequest(BaseModel):
       resolution: str  # approved, rejected, modified
       notes: Optional[str] = None


   # Endpoints
   @router.get("", response_model=List[ReviewQueueItem])
   def list_pending_reviews(
       limit: int = 50,
       db: Session = Depends(get_db)
   ):
       """List pending review items, sorted by priority (highest first) then creation time."""
       items = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.resolved_at.is_(None)
       ).order_by(
           ManualReviewQueue.priority.desc(),
           ManualReviewQueue.created_at.asc()
       ).limit(limit).all()

       return items


   @router.get("/stats")
   def get_queue_stats(db: Session = Depends(get_db)):
       """Get queue statistics."""
       total = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.resolved_at.is_(None)
       ).count()

       claimed = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.resolved_at.is_(None),
           ManualReviewQueue.claimed_at.isnot(None)
       ).count()

       by_reason = {}
       for reason in ["low_confidence", "validation_failure", "conflict_detected"]:
           count = db.query(ManualReviewQueue).filter(
               ManualReviewQueue.resolved_at.is_(None),
               ManualReviewQueue.review_reason == reason
           ).count()
           by_reason[reason] = count

       return {
           "total_pending": total,
           "claimed": claimed,
           "unclaimed": total - claimed,
           "by_reason": by_reason
       }


   @router.post("/{item_id}/claim", response_model=ReviewQueueItem)
   def claim_review_item(
       item_id: int,
       request: ClaimRequest,
       db: Session = Depends(get_db)
   ):
       """
       Claim a review item for processing.
       Uses FOR UPDATE SKIP LOCKED for safe concurrent access.
       """
       # FOR UPDATE SKIP LOCKED: if another worker already locked this row, skip it
       item = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.id == item_id,
           ManualReviewQueue.resolved_at.is_(None),
           ManualReviewQueue.claimed_at.is_(None)
       ).with_for_update(skip_locked=True).first()

       if not item:
           raise HTTPException(
               status_code=404,
               detail="Item not found, already claimed, or already resolved"
           )

       item.claimed_at = datetime.utcnow()
       item.claimed_by = request.reviewer_id
       db.commit()
       db.refresh(item)

       return item


   @router.post("/claim-next", response_model=Optional[ReviewQueueItem])
   def claim_next_review_item(
       request: ClaimRequest,
       db: Session = Depends(get_db)
   ):
       """
       Claim the next unclaimed item (highest priority, oldest first).
       Returns None if no items available.
       """
       item = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.resolved_at.is_(None),
           ManualReviewQueue.claimed_at.is_(None)
       ).order_by(
           ManualReviewQueue.priority.desc(),
           ManualReviewQueue.created_at.asc()
       ).with_for_update(skip_locked=True).first()

       if not item:
           return None

       item.claimed_at = datetime.utcnow()
       item.claimed_by = request.reviewer_id
       db.commit()
       db.refresh(item)

       return item


   @router.post("/{item_id}/resolve")
   def resolve_review_item(
       item_id: int,
       request: ResolveRequest,
       db: Session = Depends(get_db)
   ):
       """Resolve a claimed review item."""
       item = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.id == item_id
       ).first()

       if not item:
           raise HTTPException(status_code=404, detail="Item not found")

       if item.resolved_at:
           raise HTTPException(status_code=400, detail="Item already resolved")

       item.resolved_at = datetime.utcnow()
       item.resolution = request.resolution
       item.resolution_notes = request.notes
       db.commit()

       return {"status": "resolved", "item_id": item_id}


   @router.get("/{item_id}/email")
   def get_review_email_details(
       item_id: int,
       db: Session = Depends(get_db)
   ):
       """Get the email details for a review item."""
       item = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.id == item_id
       ).first()

       if not item:
           raise HTTPException(status_code=404, detail="Item not found")

       email = db.query(IncomingEmail).filter(
           IncomingEmail.id == item.email_id
       ).first()

       if not email:
           raise HTTPException(status_code=404, detail="Email not found")

       return {
           "review_item": {
               "id": item.id,
               "reason": item.review_reason,
               "details": item.review_details,
               "priority": item.priority
           },
           "email": {
               "id": email.id,
               "from_email": email.from_email,
               "subject": email.subject,
               "cleaned_body": email.cleaned_body,
               "extracted_data": email.extracted_data,
               "agent_checkpoints": email.agent_checkpoints
           }
       }
   ```

2. Update app/routers/__init__.py:
   - Add import for manual_review router

3. Update app/main.py:
   - Register manual_review router with FastAPI app
   - Add after existing router registrations
  </action>
  <verify>
    - `python -c "from app.routers.manual_review import router"`
    - Start app and test: `curl http://localhost:8000/api/reviews/stats` returns JSON
    - Check OpenAPI docs at /docs show review endpoints
  </verify>
  <done>
    - GET /api/reviews lists pending review items
    - GET /api/reviews/stats returns queue statistics
    - POST /api/reviews/{id}/claim claims an item with FOR UPDATE SKIP LOCKED
    - POST /api/reviews/claim-next claims next available item
    - POST /api/reviews/{id}/resolve marks item resolved
    - GET /api/reviews/{id}/email returns email details including checkpoints
  </done>
</task>

<task type="auto">
  <name>Task 3: Add helper to enqueue review items</name>
  <files>
    app/services/validation/review_queue.py
    app/services/validation/__init__.py
  </files>
  <action>
1. Create app/services/validation/review_queue.py:
   ```python
   """
   Review Queue Service (Phase 5: Multi-Agent Pipeline)

   Helper functions for enqueueing items to manual review.
   Called by agents when needs_review=True.
   """

   import json
   import structlog
   from typing import Optional, List, Dict, Any
   from sqlalchemy.orm import Session

   from app.models.manual_review import ManualReviewQueue

   logger = structlog.get_logger()

   # Priority mapping (higher = more urgent)
   PRIORITY_MAP = {
       "low_confidence": 1,
       "validation_failure": 2,
       "conflict_detected": 3,
       "extraction_error": 2,
   }


   def enqueue_for_review(
       db: Session,
       email_id: int,
       reason: str,
       details: Optional[Dict[str, Any]] = None
   ) -> ManualReviewQueue:
       """
       Add an item to the manual review queue.

       Args:
           db: Database session
           email_id: IncomingEmail.id
           reason: One of: low_confidence, validation_failure, conflict_detected, extraction_error
           details: Optional dict with additional info (conflicts list, validation errors, etc.)

       Returns:
           Created ManualReviewQueue item
       """
       # Check if already in queue (avoid duplicates)
       existing = db.query(ManualReviewQueue).filter(
           ManualReviewQueue.email_id == email_id,
           ManualReviewQueue.resolved_at.is_(None)
       ).first()

       if existing:
           # Update reason if higher priority
           if PRIORITY_MAP.get(reason, 1) > existing.priority:
               existing.review_reason = reason
               existing.priority = PRIORITY_MAP.get(reason, 1)
               if details:
                   existing.review_details = json.dumps(details)
               logger.info("review_item_updated",
                   email_id=email_id,
                   reason=reason,
                   priority=existing.priority)
           return existing

       # Create new item
       item = ManualReviewQueue(
           email_id=email_id,
           review_reason=reason,
           review_details=json.dumps(details) if details else None,
           priority=PRIORITY_MAP.get(reason, 1)
       )
       db.add(item)
       db.flush()  # Get ID without committing

       logger.info("review_item_enqueued",
           item_id=item.id,
           email_id=email_id,
           reason=reason,
           priority=item.priority)

       return item


   def bulk_enqueue_for_review(
       db: Session,
       items: List[Dict[str, Any]]
   ) -> List[ManualReviewQueue]:
       """
       Add multiple items to review queue.

       Args:
           items: List of dicts with email_id, reason, details

       Returns:
           List of created/updated ManualReviewQueue items
       """
       results = []
       for item in items:
           result = enqueue_for_review(
               db,
               email_id=item["email_id"],
               reason=item["reason"],
               details=item.get("details")
           )
           results.append(result)
       return results
   ```

2. Update app/services/validation/__init__.py:
   - Add exports: enqueue_for_review, bulk_enqueue_for_review
  </action>
  <verify>
    - `python -c "from app.services.validation import enqueue_for_review, bulk_enqueue_for_review"`
  </verify>
  <done>
    - enqueue_for_review adds items to ManualReviewQueue
    - Duplicate detection updates priority if higher
    - Priority based on reason type
    - Functions exported from app.services.validation
  </done>
</task>

</tasks>

<verification>
Manual Review Queue complete:
1. `python -c "from app.models import ManualReviewQueue; print(ManualReviewQueue.__tablename__)"`
2. `python -c "from app.routers.manual_review import router"`
3. `python -c "from app.services.validation import enqueue_for_review"`
4. `alembic heads` shows new migration
</verification>

<success_criteria>
- ManualReviewQueue model with claim tracking (claimed_at, claimed_by, resolved_at)
- Alembic migration for manual_review_queue table
- REST API with list, stats, claim, claim-next, resolve endpoints
- FOR UPDATE SKIP LOCKED used in claim endpoints for concurrency safety
- enqueue_for_review helper for agents to add items
- Priority-based ordering (conflict_detected > validation_failure > low_confidence)
- REQ-PIPELINE-05 (validation layer) partially addressed through review routing
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-agent-pipeline-validation/05-04-SUMMARY.md`
</output>
