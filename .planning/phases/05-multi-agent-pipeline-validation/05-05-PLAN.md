---
phase: 05-multi-agent-pipeline-validation
plan: 05
type: execute
wave: 3
depends_on: ["05-02", "05-03", "05-04"]
files_modified:
  - app/actors/email_processor.py
  - app/actors/content_extractor.py
autonomous: true

must_haves:
  truths:
    - "Pipeline routes auto_reply and spam to skip_extraction path"
    - "Pipeline stops extraction when Agent 1 confidence < 0.7 and routes to manual review"
    - "Each agent saves checkpoint before passing to next agent"
    - "Items flagged needs_review are enqueued to ManualReviewQueue"
  artifacts:
    - path: "app/actors/email_processor.py"
      provides: "Refactored to orchestrate 3-agent pipeline"
      contains: "classify_intent"
    - path: "app/actors/content_extractor.py"
      provides: "Updated to check intent and checkpoint"
      contains: "agent_1_intent"
  key_links:
    - from: "app/actors/email_processor.py"
      to: "app/actors/intent_classifier.py"
      via: "Pipeline orchestration"
      pattern: "classify_intent"
    - from: "app/actors/email_processor.py"
      to: "app/actors/consolidation_agent.py"
      via: "Pipeline orchestration"
      pattern: "consolidate_results"
    - from: "app/actors/content_extractor.py"
      to: "app/services/validation/checkpoint.py"
      via: "Checkpoint check before extraction"
      pattern: "has_valid_checkpoint|get_checkpoint"
---

<objective>
Integrate the three agents into a cohesive pipeline: refactor email_processor to orchestrate Agent 1 -> Agent 2 -> Agent 3, with validation checkpoints and manual review routing.

Purpose: Complete the multi-agent architecture with proper orchestration, skip-extraction paths, and review routing.
Output: Refactored email_processor that coordinates all three agents with validation.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-CONTEXT.md
@.planning/phases/05-multi-agent-pipeline-validation/05-RESEARCH.md

@app/actors/email_processor.py
@app/actors/content_extractor.py
@app/actors/intent_classifier.py
@app/actors/consolidation_agent.py
@app/services/validation/review_queue.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update content extractor with checkpoint and intent awareness</name>
  <files>
    app/actors/content_extractor.py
  </files>
  <action>
1. Update app/actors/content_extractor.py to:

a) Check for existing checkpoint before starting extraction (skip-on-retry pattern):
   ```python
   from app.services.validation import has_valid_checkpoint, get_checkpoint, save_checkpoint

   # At start of extract_content actor:
   # Check if we already have a valid checkpoint (for retry scenarios)
   if has_valid_checkpoint(db, email_id, "agent_2_extraction"):
       logger.info("checkpoint_reused", email_id=email_id, agent="agent_2_extraction")
       return get_checkpoint(db, email_id, "agent_2_extraction")
   ```

b) Accept intent_result parameter from Agent 1:
   ```python
   @dramatiq.actor(...)
   def extract_content(
       email_id: int,
       email_body: Optional[str],
       attachment_urls: Optional[List[Dict[str, Any]]],
       intent_result: Optional[Dict[str, Any]] = None  # From Agent 1
   ) -> Dict[str, Any]:
   ```

c) Skip extraction for auto_reply and spam intents (USER DECISION):
   ```python
   # Check if we should skip extraction
   if intent_result and intent_result.get("skip_extraction"):
       logger.info("extraction_skipped",
           email_id=email_id,
           intent=intent_result.get("intent"),
           reason="skip_extraction_intent")
       return {
           "email_id": email_id,
           "skipped": True,
           "reason": f"intent:{intent_result.get('intent')}",
           "gesamtforderung": None,
           "confidence": intent_result.get("confidence", 0.5)
       }
   ```

d) Check Agent 1 confidence threshold before extraction (REQ-PIPELINE-06):
   ```python
   # Agent 2 refuses if Agent 1 confidence < 0.7 (USER DECISION)
   if intent_result and intent_result.get("confidence", 1.0) < 0.7:
       logger.warning("extraction_refused_low_intent_confidence",
           email_id=email_id,
           confidence=intent_result.get("confidence"))
       return {
           "email_id": email_id,
           "skipped": True,
           "reason": "low_intent_confidence",
           "needs_review": True,
           "gesamtforderung": None,
           "confidence": intent_result.get("confidence")
       }
   ```

e) Save checkpoint after successful extraction:
   ```python
   # After extraction completes, before returning:
   checkpoint_data = {
       "gesamtforderung": result.gesamtforderung,
       "client_name": result.client_name,
       "creditor_name": result.creditor_name,
       "confidence": result.confidence,
       "sources_processed": result.sources_processed,
       "sources_with_amount": result.sources_with_amount,
       "total_tokens_used": result.total_tokens_used,
       "validation_status": "passed"
   }
   save_checkpoint(db, email_id, "agent_2_extraction", checkpoint_data)
   ```

f) Add needs_review flag to return dict if confidence < 0.7:
   ```python
   from app.services.validation import check_confidence_threshold

   confidence_check = check_confidence_threshold(confidence_float)
   return {
       ...
       "needs_review": confidence_check["needs_review"]
   }
   ```
  </action>
  <verify>
    - `python -c "from app.actors.content_extractor import extract_content"`
    - Check that function signature includes intent_result parameter
  </verify>
  <done>
    - Content extractor checks for valid checkpoint before starting (skip-on-retry)
    - Skips extraction for auto_reply and spam intents
    - Refuses extraction when Agent 1 confidence < 0.7
    - Saves checkpoint after extraction
    - Returns needs_review flag when confidence < 0.7
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor email_processor for 3-agent pipeline orchestration</name>
  <files>
    app/actors/email_processor.py
  </files>
  <action>
1. Refactor app/actors/email_processor.py to orchestrate the 3-agent pipeline:

a) Add imports at top:
   ```python
   from app.actors.intent_classifier import classify_intent
   from app.actors.consolidation_agent import consolidate_results
   from app.services.validation import (
       save_checkpoint,
       get_checkpoint,
       has_valid_checkpoint,
       enqueue_for_review,
       check_confidence_threshold,
   )
   from app.models.intent_classification import EmailIntent
   ```

b) Replace the current monolithic processing with pipeline stages:

   **Stage 1: Intent Classification (Agent 1)**
   - After parsing email body, call intent classification
   - Check for skip_extraction (auto_reply, spam)
   - If skip_extraction: mark as not_creditor_reply and return early
   - If confidence < 0.7 AND NOT skip_extraction: route to manual review

   ```python
   # Step 4: Agent 1 - Intent Classification
   logger.info("agent_1_intent_classification", email_id=email_id)
   email.processing_status = "classifying_intent"
   db.commit()

   from app.services.intent_classifier import classify_email_intent

   # Parse headers (limited from Zendesk webhook)
   headers = {
       "From": email.from_email or "",
       "Subject": email.subject or "",
   }

   intent_result = classify_email_intent(
       email_id=email_id,
       headers=headers,
       subject=email.subject or "",
       body=email.cleaned_body or ""
   )

   # Save Agent 1 checkpoint
   save_checkpoint(db, email_id, "agent_1_intent", {
       "intent": intent_result.intent.value,
       "confidence": intent_result.confidence,
       "method": intent_result.method,
       "skip_extraction": intent_result.skip_extraction,
       "validation_status": "passed"
   })

   # Handle skip_extraction intents (auto_reply, spam)
   if intent_result.skip_extraction:
       logger.info("skipping_extraction",
           email_id=email_id,
           intent=intent_result.intent.value)
       email.processing_status = "not_creditor_reply"
       email.match_status = "no_match"
       email.extracted_data = {
           "is_creditor_reply": False,
           "intent": intent_result.intent.value,
           "confidence": intent_result.confidence,
           "skip_reason": "auto_reply_or_spam"
       }
       email.completed_at = datetime.utcnow()
       email.processed_at = datetime.utcnow()
       db.commit()
       return

   # Check confidence threshold (USER DECISION: 0.7)
   if intent_result.confidence < 0.7:
       logger.warning("low_intent_confidence_routing_to_review",
           email_id=email_id,
           confidence=intent_result.confidence)
       # Continue extraction but flag for review
       # REQ-PIPELINE-06: Agent 2 refuses, routes to manual review
       # But USER DECISION says proceed with flag, don't block
       # So we set needs_review but continue
   ```

   **Stage 2: Content Extraction (Agent 2)**
   - Call extraction with intent_result passed through
   - Existing ContentExtractionService handles email body + attachments
   - Check for needs_review flag

   ```python
   # Step 5: Agent 2 - Content Extraction
   logger.info("agent_2_content_extraction", email_id=email_id)
   email.processing_status = "content_extracting"
   db.commit()

   # Prepare intent data for Agent 2
   intent_data = {
       "intent": intent_result.intent.value,
       "confidence": intent_result.confidence,
       "skip_extraction": intent_result.skip_extraction
   }

   extraction_service = ContentExtractionService(redis_client=_get_redis_client())
   phase3_result = extraction_service.extract_all(
       email_body=email.cleaned_body or email.raw_body_text,
       attachment_urls=email.attachment_urls or []
   )

   # Convert confidence string to float
   confidence_float = _confidence_to_float(phase3_result.confidence)

   # Save Agent 2 checkpoint
   save_checkpoint(db, email_id, "agent_2_extraction", {
       "gesamtforderung": phase3_result.gesamtforderung,
       "client_name": phase3_result.client_name,
       "creditor_name": phase3_result.creditor_name,
       "confidence": phase3_result.confidence,
       "sources_processed": phase3_result.sources_processed,
       "total_tokens_used": phase3_result.total_tokens_used,
       "validation_status": "passed"
   })

   # Check extraction confidence
   extraction_needs_review = check_confidence_threshold(confidence_float)["needs_review"]
   ```

   **Stage 3: Consolidation (Agent 3)**
   - Call consolidation with extraction results
   - Detect conflicts with existing database records
   - Final needs_review determination

   ```python
   # Step 6: Agent 3 - Consolidation
   logger.info("agent_3_consolidation", email_id=email_id)
   email.processing_status = "consolidating"
   db.commit()

   # Prepare extraction data for consolidation
   extraction_data = {
       "email_id": email_id,
       "gesamtforderung": phase3_result.gesamtforderung,
       "client_name": phase3_result.client_name,
       "creditor_name": phase3_result.creditor_name,
       "confidence": confidence_float,
       "sources_processed": phase3_result.sources_processed,
       "needs_review": extraction_needs_review or (intent_result.confidence < 0.7)
   }

   from app.services.validation import detect_database_conflicts

   # Get existing data for conflict detection
   existing_data = _get_existing_creditor_data(
       client_name=phase3_result.client_name,
       creditor_email=email.from_email
   )

   conflicts = detect_database_conflicts(extraction_data, existing_data)

   # Final needs_review determination
   needs_review = (
       extraction_needs_review or
       intent_result.confidence < 0.7 or
       len(conflicts) > 0
   )

   # Save Agent 3 checkpoint
   save_checkpoint(db, email_id, "agent_3_consolidation", {
       "final_amount": phase3_result.gesamtforderung,
       "confidence": confidence_float,
       "conflicts_detected": len(conflicts),
       "conflicts": conflicts,
       "validation_status": "needs_review" if needs_review else "passed"
   })

   # Enqueue to review if needed
   if needs_review:
       reason = "conflict_detected" if conflicts else "low_confidence"
       enqueue_for_review(db, email_id, reason, {
           "intent_confidence": intent_result.confidence,
           "extraction_confidence": confidence_float,
           "conflicts": conflicts
       })
   ```

c) Update the extracted_data storage to include pipeline metadata:
   ```python
   email.extracted_data = {
       "is_creditor_reply": True,
       "intent": intent_result.intent.value,
       "client_name": phase3_result.client_name,
       "creditor_name": phase3_result.creditor_name,
       "debt_amount": phase3_result.gesamtforderung,
       "reference_numbers": [],  # Will be populated by entity extraction
       "confidence": confidence_float,
       "needs_review": needs_review,
       "pipeline_metadata": {
           "agent_1_method": intent_result.method,
           "agent_1_confidence": intent_result.confidence,
           "agent_2_sources": phase3_result.sources_processed,
           "agent_2_tokens": phase3_result.total_tokens_used,
           "agent_3_conflicts": len(conflicts)
       }
   }
   ```

d) Remove the duplicate entity extraction call (LLM) since Agent 1 now handles intent classification
   - Keep the existing is_creditor_reply check but base it on intent classification
   - The entity_extractor.extract_entities call can be simplified or removed since Agent 2 extracts client_name, creditor_name, debt_amount

e) Keep the matching and dual-write logic (Steps 6-7 in current code) - those are Phase 6 scope
  </action>
  <verify>
    - `python -c "from app.actors.email_processor import process_email"`
    - Check that email_processor imports intent_classifier and validation modules
    - Review refactored code handles all three agents in sequence
  </verify>
  <done>
    - email_processor orchestrates Agent 1 -> Agent 2 -> Agent 3
    - Checkpoints saved after each agent
    - Auto-reply and spam skip extraction and mark as not_creditor_reply
    - Low confidence routes to manual review queue
    - Conflicts detected and trigger review queue
    - extracted_data includes pipeline_metadata
    - REQ-PIPELINE-01 through REQ-PIPELINE-06 addressed
    - REQ-PIPELINE-07 (checkpoint system) addressed
  </done>
</task>

</tasks>

<verification>
Pipeline Integration complete:
1. `python -c "from app.actors.email_processor import process_email; from app.actors.intent_classifier import classify_intent"`
2. `python -c "from app.actors.content_extractor import extract_content"` - verify intent_result parameter exists
3. Review app/actors/email_processor.py contains:
   - "agent_1_intent" checkpoint save
   - "agent_2_extraction" checkpoint save
   - "agent_3_consolidation" checkpoint save
   - enqueue_for_review call
4. `grep -n "skip_extraction" app/actors/email_processor.py` shows skip path for auto_reply/spam
</verification>

<success_criteria>
- email_processor calls Agent 1 (intent classification) after parsing
- Auto-reply and spam intents skip extraction and complete as not_creditor_reply
- Agent 2 receives intent_result and checks confidence threshold
- Agent 3 detects conflicts with existing database records
- Checkpoints saved at each stage (agent_1_intent, agent_2_extraction, agent_3_consolidation)
- Items with needs_review=True enqueued to ManualReviewQueue
- extracted_data includes pipeline_metadata
- All REQ-PIPELINE requirements addressed:
  - REQ-PIPELINE-01: Agent 1 parses, classifies, routes
  - REQ-PIPELINE-02: 6 intent types with routing
  - REQ-PIPELINE-03: Agent 2 processes sources
  - REQ-PIPELINE-04: Agent 3 merges and computes confidence
  - REQ-PIPELINE-05: Validation after each agent
  - REQ-PIPELINE-06: Confidence < 0.7 routes to review
  - REQ-PIPELINE-07: Checkpoint system
  - REQ-PIPELINE-08: Conflict detection
</success_criteria>

<output>
After completion, create `.planning/phases/05-multi-agent-pipeline-validation/05-05-SUMMARY.md`
</output>
