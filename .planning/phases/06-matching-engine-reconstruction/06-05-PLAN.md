---
phase: 06-matching-engine-reconstruction
plan: 05
type: execute
wave: 4
depends_on: ["06-04"]
files_modified:
  - app/actors/email_processor.py
  - app/services/review_queue.py
autonomous: true

must_haves:
  truths:
    - "Email processor uses MatchingEngineV2 instead of bypassed direct MongoDB writes"
    - "Ambiguous matches route to ManualReviewQueue with top-3 candidates"
    - "Auto-matched emails update both databases via DualDatabaseWriter"
    - "Match results persisted with explainability JSONB"
  artifacts:
    - path: "app/actors/email_processor.py"
      provides: "Updated email processor with matching engine integration"
      contains: "MatchingEngineV2"
    - path: "app/services/review_queue.py"
      provides: "Helper service for enqueueing ambiguous matches"
      exports: ["enqueue_ambiguous_match"]
  key_links:
    - from: "app/actors/email_processor.py"
      to: "app/services/matching_engine_v2.py"
      via: "engine.find_match()"
      pattern: "engine.find_match\\("
    - from: "app/actors/email_processor.py"
      to: "app/models/manual_review.py"
      via: "enqueue_for_review"
      pattern: "enqueue_for_review\\(.*ambiguous"
---

<objective>
Integrate MatchingEngineV2 into the email processing pipeline, replacing the bypassed v1 matching logic.

Purpose: Wire the reconstructed matching engine into production flow with proper ambiguity handling.
Output: Updated email_processor.py using MatchingEngineV2; ambiguous matches routed to review queue.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-matching-engine-reconstruction/06-CONTEXT.md
@.planning/phases/06-matching-engine-reconstruction/06-RESEARCH.md

# Current email processor to modify
@app/actors/email_processor.py

# Manual review queue model
@app/models/manual_review.py

# Prior plan artifacts
# 06-04: MatchingEngineV2 with find_match() and save_match_results()
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create review_queue service for ambiguous match handling</name>
  <files>app/services/review_queue.py</files>
  <action>
Create `app/services/review_queue.py` with helper function for enqueueing ambiguous matches:

```python
"""
Review Queue Service (Phase 6: Matching Engine Reconstruction)

Provides helper functions for enqueueing items to ManualReviewQueue,
specifically for ambiguous match scenarios.

CONTEXT.MD: Reviewer sees all candidates with their match scores and signal breakdown.
"""

from typing import List, Dict, Any, Optional
from sqlalchemy.orm import Session
import structlog

from app.models import ManualReviewQueue
from app.services.matching_engine_v2 import MatchCandidate, MatchingResult

logger = structlog.get_logger(__name__)


# Priority mapping for review reasons
PRIORITY_MAP = {
    "ambiguous_match": 3,  # Multiple close candidates
    "no_recent_inquiry": 4,  # No candidates in 30-day window
    "below_threshold": 5,  # Low confidence match
    "conflict_detected": 2,  # Data conflicts (from Phase 5)
    "low_confidence": 5,  # From Phase 5 validation
    "manual_escalation": 1,  # User-triggered
}


def enqueue_ambiguous_match(
    db: Session,
    email_id: int,
    matching_result: MatchingResult,
) -> Optional[int]:
    """
    Enqueue an ambiguous match to the manual review queue.

    CONTEXT.MD: Reviewer sees all candidates with match scores and signal breakdown.
    Below-threshold candidates not shown to avoid information overload.

    Args:
        db: SQLAlchemy session
        email_id: IncomingEmail.id
        matching_result: MatchingResult from MatchingEngineV2

    Returns:
        ManualReviewQueue.id if enqueued, None if duplicate exists
    """
    # Check for duplicate (don't enqueue same email twice for matching)
    existing = db.query(ManualReviewQueue).filter(
        ManualReviewQueue.email_id == email_id,
        ManualReviewQueue.review_reason.in_(["ambiguous_match", "no_recent_inquiry", "below_threshold"]),
        ManualReviewQueue.resolved_at.is_(None)
    ).first()

    if existing:
        logger.debug("duplicate_review_skipped",
                    email_id=email_id,
                    existing_id=existing.id)
        return None

    # Build candidate details for reviewer
    top_candidates = []
    for candidate in matching_result.candidates[:3]:
        top_candidates.append({
            "inquiry_id": candidate.inquiry.id,
            "client_name": candidate.inquiry.client_name,
            "creditor_name": candidate.inquiry.creditor_name,
            "creditor_email": candidate.inquiry.creditor_email,
            "reference_number": candidate.inquiry.reference_number,
            "sent_at": candidate.inquiry.sent_at.isoformat() if candidate.inquiry.sent_at else None,
            "total_score": round(candidate.total_score, 4),
            "confidence_level": candidate.confidence_level,
            # CONTEXT.MD: Signal breakdown for reviewer
            "signal_breakdown": {
                "client_name_score": round(candidate.component_scores.get("client_name", 0), 4),
                "reference_score": round(candidate.component_scores.get("reference", 0), 4),
            },
            "strategy_used": candidate.strategy_used
        })

    # Build review details
    review_details = {
        "match_status": matching_result.status,
        "gap": round(matching_result.gap, 4) if matching_result.gap is not None else None,
        "gap_threshold": matching_result.gap_threshold,
        "top_candidates": top_candidates,
        "review_reason": matching_result.review_reason,
        "instructions": _get_review_instructions(matching_result.status)
    }

    # Determine priority and reason
    review_reason = f"{matching_result.status}"
    priority = PRIORITY_MAP.get(matching_result.status, 5)

    # Create queue entry
    queue_entry = ManualReviewQueue(
        email_id=email_id,
        review_reason=review_reason,
        review_details=review_details,
        priority=priority
    )

    db.add(queue_entry)
    db.flush()  # Get ID

    logger.info("ambiguous_match_enqueued",
               email_id=email_id,
               queue_id=queue_entry.id,
               status=matching_result.status,
               num_candidates=len(top_candidates),
               priority=priority)

    return queue_entry.id


def _get_review_instructions(status: str) -> str:
    """Return instructions for reviewer based on match status."""
    instructions = {
        "ambiguous_match": (
            "Multiple candidates have similar scores. Review the signal breakdown "
            "to select the correct match. Consider client name similarity and "
            "reference number accuracy."
        ),
        "below_threshold": (
            "Top candidate score is below minimum threshold. Verify if any "
            "candidate is the correct match, or mark as no_match if none apply."
        ),
        "no_recent_inquiry": (
            "No inquiries found in the 30-day window. This email may be a response "
            "to an older inquiry or from an unknown creditor. Manual investigation required."
        )
    }
    return instructions.get(status, "Review required. Please select appropriate action.")


__all__ = ["enqueue_ambiguous_match", "PRIORITY_MAP"]
```
  </action>
  <verify>python -c "from app.services.review_queue import enqueue_ambiguous_match; print('OK')"</verify>
  <done>enqueue_ambiguous_match function imports and accepts matching_result parameter</done>
</task>

<task type="auto">
  <name>Task 2: Integrate MatchingEngineV2 into email_processor.py</name>
  <files>app/actors/email_processor.py</files>
  <action>
Update `app/actors/email_processor.py` to use MatchingEngineV2 instead of bypassed direct MongoDB writes.

**Locate the matching section (around line 424-527)** where it currently:
1. Validates required fields
2. Generates idempotency key
3. Creates DualDatabaseWriter
4. Calls dual_writer.update_creditor_debt()
5. Executes MongoDB write

**Replace with:**

```python
        # ========================================
        # PHASE 6: Matching Engine Integration
        # ========================================

        # Step 6: Match using MatchingEngineV2
        logger.info("matching_with_v2_engine", email_id=email_id)
        email.processing_status = "matching"
        db.commit()

        from app.services.matching_engine_v2 import MatchingEngineV2
        from app.services.review_queue import enqueue_ambiguous_match

        # Build extracted_data for matching engine
        matching_input = {
            "client_name": final_extracted.get("client_name"),
            "creditor_name": final_extracted.get("creditor_name"),
            "reference_numbers": final_extracted.get("reference_numbers", []),
            "debt_amount": final_extracted.get("debt_amount"),
        }

        # Run matching engine
        engine = MatchingEngineV2(db)
        matching_result = engine.find_match(
            email_id=email_id,
            extracted_data=matching_input,
            from_email=email.from_email,
            received_at=email.received_at
        )

        # Save match results to database (for explainability/audit)
        engine.save_match_results(email_id, matching_result)

        logger.info("matching_result",
                   email_id=email_id,
                   status=matching_result.status,
                   gap=matching_result.gap,
                   needs_review=matching_result.needs_review)

        # Handle matching outcomes
        if matching_result.status == "auto_matched":
            # SUCCESS: Clear match found
            matched_inquiry = matching_result.match.inquiry

            # Update email with match info
            email.matched_inquiry_id = matched_inquiry.id
            email.match_confidence = int(matching_result.match.total_score * 100)
            email.match_status = "auto_matched"
            email.matched_at = datetime.utcnow()

            logger.info("auto_match_success",
                       email_id=email_id,
                       inquiry_id=matched_inquiry.id,
                       client_name=matched_inquiry.client_name,
                       score=matching_result.match.total_score)

            # Execute DualDatabaseWriter with matched inquiry data
            idempotency_key = generate_idempotency_key(
                operation="creditor_debt_update",
                aggregate_id=str(email_id),
                payload={
                    "client_name": matched_inquiry.client_name,
                    "creditor_email": matched_inquiry.creditor_email,
                    "amount": final_extracted.get("debt_amount")
                }
            )

            idempotency_svc = IdempotencyService(SessionLocal)
            dual_writer = DualDatabaseWriter(db, idempotency_svc)

            result = dual_writer.update_creditor_debt(
                email_id=email_id,
                client_name=matched_inquiry.client_name,
                client_aktenzeichen=matched_inquiry.reference_number,
                creditor_email=matched_inquiry.creditor_email,
                creditor_name=matched_inquiry.creditor_name,
                new_debt_amount=final_extracted.get("debt_amount"),
                response_text=final_extracted.get("summary"),
                reference_numbers=final_extracted.get("reference_numbers", []),
                idempotency_key=idempotency_key
            )

            db.commit()

            # Attempt MongoDB write
            mongodb_success = False
            if result.get("outbox_message_id"):
                mongodb_success = dual_writer.execute_mongodb_write(result["outbox_message_id"])

            if mongodb_success:
                logger.info("mongodb_update_success",
                           email_id=email_id,
                           client_name=matched_inquiry.client_name)

                # Send notification
                email_notifier.send_debt_update_notification(
                    client_name=matched_inquiry.client_name,
                    creditor_name=matched_inquiry.creditor_name,
                    creditor_email=matched_inquiry.creditor_email,
                    old_debt_amount=None,
                    new_debt_amount=final_extracted.get("debt_amount"),
                    side_conversation_id="N/A",
                    zendesk_ticket_id=email.zendesk_ticket_id,
                    reference_numbers=final_extracted.get("reference_numbers", []),
                    confidence_score=matching_result.match.total_score
                )
            else:
                logger.warning("mongodb_update_failed", email_id=email_id)
                email.sync_status = "failed"

        else:
            # NEEDS REVIEW: ambiguous, below_threshold, or no_recent_inquiry
            email.match_status = matching_result.status
            email.match_confidence = int(matching_result.candidates[0].total_score * 100) if matching_result.candidates else 0

            # Enqueue to manual review with candidate details
            queue_id = enqueue_ambiguous_match(db, email_id, matching_result)

            if queue_id:
                logger.info("enqueued_for_manual_review",
                           email_id=email_id,
                           queue_id=queue_id,
                           status=matching_result.status,
                           reason=matching_result.review_reason)

        # Step 7: Mark as completed
        email.processing_status = "completed"
        email.completed_at = datetime.utcnow()
        email.processed_at = datetime.utcnow()
        db.commit()

        logger.info("email_processing_completed",
                   email_id=email_id,
                   match_status=email.match_status)
```

**Important:** Keep the existing imports at the top of the file. Add new imports:
```python
from app.services.matching_engine_v2 import MatchingEngineV2
from app.services.review_queue import enqueue_ambiguous_match
```

**Remove the old direct MongoDB matching code** (the section that validates fields, creates idempotency key, etc.) and replace it with the Phase 6 matching engine integration above.

Note: The old code starting around line 424 (`# Step 6: Match and write using DualDatabaseWriter`) should be replaced entirely with the new Phase 6 matching logic.
  </action>
  <verify>python -c "from app.actors.email_processor import process_email; print('OK')"</verify>
  <done>email_processor.py imports MatchingEngineV2 and uses engine.find_match() for matching</done>
</task>

<task type="auto">
  <name>Task 3: Add matching-related config to settings</name>
  <files>app/config.py</files>
  <action>
Add matching-related configuration to `app/config.py` Settings class:

```python
    # Matching Engine Configuration (Phase 6)
    match_lookback_days: int = 30  # creditor_inquiries window
    match_threshold_high: float = 0.85  # High confidence threshold
    match_threshold_medium: float = 0.70  # Medium confidence threshold
```

These provide application-level defaults that can be overridden by:
1. Database matching_thresholds table (per-category)
2. Environment variables

The ThresholdManager in MatchingEngineV2 will query database first, fall back to these.
  </action>
  <verify>python -c "from app.config import settings; print(f'lookback: {settings.match_lookback_days}')"</verify>
  <done>Config has match_lookback_days, match_threshold_high, match_threshold_medium</done>
</task>

</tasks>

<verification>
1. email_processor.py imports MatchingEngineV2: `grep "MatchingEngineV2" app/actors/email_processor.py`
2. engine.find_match() called in email processor: `grep "engine.find_match" app/actors/email_processor.py`
3. enqueue_ambiguous_match used for non-auto-matched: `grep "enqueue_ambiguous_match" app/actors/email_processor.py`
4. Config has matching settings: `python -c "from app.config import settings; print(settings.match_lookback_days)"`
5. Python syntax valid: `python -m py_compile app/actors/email_processor.py`
</verification>

<success_criteria>
- MatchingEngineV2 integrated into email_processor.py pipeline
- Auto-matched emails proceed to DualDatabaseWriter + MongoDB update
- Ambiguous/below_threshold/no_recent_inquiry emails enqueued to ManualReviewQueue
- Match results saved with explainability JSONB for all candidates
- Review queue entry includes top-3 candidates with signal breakdown
- Config settings provide application-level defaults
</success_criteria>

<output>
After completion, create `.planning/phases/06-matching-engine-reconstruction/06-05-SUMMARY.md`
</output>
