---
phase: 06-matching-engine-reconstruction
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - app/services/matching/thresholds.py
  - app/services/matching/strategies.py
  - app/services/matching/__init__.py
autonomous: true

must_haves:
  truths:
    - "ThresholdManager queries database for category-specific thresholds at runtime"
    - "Multiple matching strategies available: exact, fuzzy, combined"
    - "Fallback to default thresholds when category not configured"
  artifacts:
    - path: "app/services/matching/thresholds.py"
      provides: "ThresholdManager class for runtime threshold lookup"
      exports: ["ThresholdManager"]
    - path: "app/services/matching/strategies.py"
      provides: "Matching strategy implementations"
      exports: ["MatchingStrategy", "ExactMatchStrategy", "FuzzyMatchStrategy", "CombinedStrategy"]
  key_links:
    - from: "app/services/matching/thresholds.py"
      to: "app/models/matching_config.py"
      via: "SQLAlchemy query"
      pattern: "db.query\\(MatchingThreshold\\)"
    - from: "app/services/matching/strategies.py"
      to: "app/services/matching/signals.py"
      via: "signal scorer imports"
      pattern: "from app.services.matching.signals import"
---

<objective>
Create ThresholdManager for database-driven configuration and matching strategies (exact, fuzzy, combined).

Purpose: ThresholdManager enables runtime threshold tuning; strategies provide REQ-MATCH-05 multiple matching approaches.
Output: ThresholdManager class + three matching strategy classes.
</objective>

<execution_context>
@/Users/luka.s/.claude/get-shit-done/workflows/execute-plan.md
@/Users/luka.s/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/06-matching-engine-reconstruction/06-CONTEXT.md
@.planning/phases/06-matching-engine-reconstruction/06-RESEARCH.md

# Prior plan artifacts needed
# 06-01: MatchingThreshold model
# 06-02: Signal scorers
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThresholdManager for runtime database-driven configuration</name>
  <files>app/services/matching/thresholds.py</files>
  <action>
Create `app/services/matching/thresholds.py` with ThresholdManager class:

```python
from typing import Dict, Optional
from sqlalchemy.orm import Session
import structlog

from app.models.matching_config import MatchingThreshold

logger = structlog.get_logger(__name__)


class ThresholdManager:
    """
    Runtime threshold lookup with category-based overrides.

    CONTEXT.MD: Thresholds stored in PostgreSQL for runtime changes without deployment.
    Developers manage via direct database access (no admin API needed).
    """

    # Hardcoded fallbacks if database has no config
    DEFAULT_MIN_MATCH = 0.70
    DEFAULT_GAP_THRESHOLD = 0.15
    DEFAULT_WEIGHTS = {"client_name": 0.40, "reference_number": 0.60}

    def __init__(self, db: Session):
        self.db = db
        self._cache: Dict[str, any] = {}  # Optional performance cache

    def get_threshold(self, creditor_category: str, threshold_type: str) -> float:
        """
        Get threshold with category override fallback to default.

        Args:
            creditor_category: "bank", "inkasso", "agency", etc.
            threshold_type: "min_match", "gap_threshold"

        Returns:
            Threshold value (0.0-1.0)
        """
        # Try category-specific first
        threshold = self.db.query(MatchingThreshold).filter(
            MatchingThreshold.category == creditor_category,
            MatchingThreshold.threshold_type == threshold_type
        ).first()

        if threshold:
            logger.debug("threshold_found_category",
                        category=creditor_category,
                        threshold_type=threshold_type,
                        value=float(threshold.threshold_value))
            return float(threshold.threshold_value)

        # Fallback to default category
        default = self.db.query(MatchingThreshold).filter(
            MatchingThreshold.category == "default",
            MatchingThreshold.threshold_type == threshold_type
        ).first()

        if default:
            logger.debug("threshold_fallback_default",
                        category=creditor_category,
                        threshold_type=threshold_type,
                        value=float(default.threshold_value))
            return float(default.threshold_value)

        # Hardcoded fallback if database empty
        hardcoded = self.DEFAULT_MIN_MATCH if threshold_type == "min_match" else self.DEFAULT_GAP_THRESHOLD
        logger.warning("threshold_hardcoded_fallback",
                      category=creditor_category,
                      threshold_type=threshold_type,
                      value=hardcoded)
        return hardcoded

    def get_weights(self, creditor_category: str) -> Dict[str, float]:
        """
        Get signal weights for category.

        CONTEXT.MD: 40% name, 60% reference suggested for default.

        Returns:
            Dict with weight_name -> weight_value
        """
        weights = self.db.query(MatchingThreshold).filter(
            MatchingThreshold.category == creditor_category,
            MatchingThreshold.weight_name.isnot(None)
        ).all()

        if not weights:
            # Fallback to default category
            weights = self.db.query(MatchingThreshold).filter(
                MatchingThreshold.category == "default",
                MatchingThreshold.weight_name.isnot(None)
            ).all()

        if weights:
            result = {w.weight_name: float(w.weight_value) for w in weights}
            logger.debug("weights_loaded", category=creditor_category, weights=result)
            return result

        # Hardcoded fallback
        logger.warning("weights_hardcoded_fallback", category=creditor_category)
        return self.DEFAULT_WEIGHTS.copy()

    def get_min_match(self, creditor_category: str = "default") -> float:
        """Convenience method for min_match threshold."""
        return self.get_threshold(creditor_category, "min_match")

    def get_gap_threshold(self, creditor_category: str = "default") -> float:
        """Convenience method for gap_threshold."""
        return self.get_threshold(creditor_category, "gap_threshold")
```
  </action>
  <verify>python -c "from app.services.matching.thresholds import ThresholdManager; print('OK')"</verify>
  <done>ThresholdManager imports and has get_threshold, get_weights methods</done>
</task>

<task type="auto">
  <name>Task 2: Create matching strategies (exact, fuzzy, combined)</name>
  <files>app/services/matching/strategies.py</files>
  <action>
Create `app/services/matching/strategies.py` implementing REQ-MATCH-05 multiple strategies:

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
import structlog

from app.services.matching.signals import score_client_name, score_reference_numbers

logger = structlog.get_logger(__name__)


@dataclass
class StrategyResult:
    """Result from a matching strategy evaluation."""
    score: float  # 0.0 to 1.0
    component_scores: Dict[str, float]  # Raw scores before weighting
    signal_details: Dict[str, Dict]  # Details from signal scorers
    strategy_used: str  # "exact", "fuzzy", "combined"


class MatchingStrategy(ABC):
    """Base class for matching strategies (REQ-MATCH-05)."""

    @abstractmethod
    def evaluate(
        self,
        inquiry: "CreditorInquiry",
        extracted_data: Dict[str, Any],
        weights: Dict[str, float]
    ) -> StrategyResult:
        """
        Evaluate match between inquiry and extracted data.

        Args:
            inquiry: CreditorInquiry to match against
            extracted_data: Extracted entities from email (client_name, reference_numbers, etc.)
            weights: Signal weights from ThresholdManager

        Returns:
            StrategyResult with score, component scores, and details
        """
        pass


class ExactMatchStrategy(MatchingStrategy):
    """
    Exact matching strategy.
    Returns 1.0 only if both name AND reference match exactly (case-insensitive).
    """

    def evaluate(
        self,
        inquiry: "CreditorInquiry",
        extracted_data: Dict[str, Any],
        weights: Dict[str, float]
    ) -> StrategyResult:
        extracted_name = extracted_data.get("client_name", "")
        extracted_refs = extracted_data.get("reference_numbers", [])
        inquiry_ref = inquiry.reference_number or ""

        # Exact name match (case-insensitive, normalized)
        inquiry_name = (inquiry.client_name_normalized or inquiry.client_name or "").lower().strip()
        name_match = extracted_name.lower().strip() == inquiry_name if extracted_name else False

        # Exact reference match
        ref_match = any(
            ref.lower().strip() == inquiry_ref.lower().strip()
            for ref in extracted_refs
        ) if extracted_refs and inquiry_ref else False

        # CONTEXT.MD: Both signals required
        if name_match and ref_match:
            score = 1.0
        elif name_match or ref_match:
            score = 0.5  # Partial match
        else:
            score = 0.0

        return StrategyResult(
            score=score,
            component_scores={
                "client_name": 1.0 if name_match else 0.0,
                "reference": 1.0 if ref_match else 0.0
            },
            signal_details={
                "client_name": {"algorithm": "exact", "matched": name_match},
                "reference": {"algorithm": "exact", "matched": ref_match}
            },
            strategy_used="exact"
        )


class FuzzyMatchStrategy(MatchingStrategy):
    """
    Fuzzy matching strategy using RapidFuzz.
    Uses signal scorers from signals.py for sophisticated fuzzy matching.
    """

    def evaluate(
        self,
        inquiry: "CreditorInquiry",
        extracted_data: Dict[str, Any],
        weights: Dict[str, float]
    ) -> StrategyResult:
        extracted_name = extracted_data.get("client_name")
        extracted_refs = extracted_data.get("reference_numbers", [])

        # Score name using signal scorer
        name_score, name_details = score_client_name(
            inquiry.client_name,
            inquiry.client_name_normalized,
            extracted_name
        )

        # Score reference using signal scorer
        ref_score, ref_details = score_reference_numbers(
            inquiry.reference_number,
            extracted_refs
        )

        # CONTEXT.MD: Both signals required for match
        # If either is 0, heavily penalize overall score
        if name_score == 0 or ref_score == 0:
            total_score = 0.0
        else:
            # Weighted average
            name_weight = weights.get("client_name", 0.4)
            ref_weight = weights.get("reference_number", 0.6)
            total_score = (name_score * name_weight) + (ref_score * ref_weight)

        return StrategyResult(
            score=total_score,
            component_scores={
                "client_name": name_score,
                "reference": ref_score
            },
            signal_details={
                "client_name": name_details,
                "reference": ref_details
            },
            strategy_used="fuzzy"
        )


class CombinedStrategy(MatchingStrategy):
    """
    Combined strategy: try exact first, fall back to fuzzy.
    Provides best of both: fast exact matches, robust fuzzy fallback.
    """

    def __init__(self):
        self.exact = ExactMatchStrategy()
        self.fuzzy = FuzzyMatchStrategy()

    def evaluate(
        self,
        inquiry: "CreditorInquiry",
        extracted_data: Dict[str, Any],
        weights: Dict[str, float]
    ) -> StrategyResult:
        # Try exact match first
        exact_result = self.exact.evaluate(inquiry, extracted_data, weights)

        if exact_result.score == 1.0:
            logger.debug("combined_strategy_exact_match",
                        inquiry_id=inquiry.id,
                        score=exact_result.score)
            exact_result.strategy_used = "combined_exact"
            return exact_result

        # Fall back to fuzzy
        fuzzy_result = self.fuzzy.evaluate(inquiry, extracted_data, weights)
        fuzzy_result.strategy_used = "combined_fuzzy"

        logger.debug("combined_strategy_fuzzy_fallback",
                    inquiry_id=inquiry.id,
                    exact_score=exact_result.score,
                    fuzzy_score=fuzzy_result.score)

        return fuzzy_result
```

Default export: CombinedStrategy (recommended for production use).
  </action>
  <verify>python -c "from app.services.matching.strategies import CombinedStrategy, FuzzyMatchStrategy, ExactMatchStrategy; print('OK')"</verify>
  <done>All three strategy classes import and are instantiable</done>
</task>

<task type="auto">
  <name>Task 3: Update matching package exports</name>
  <files>app/services/matching/__init__.py</files>
  <action>
Update `app/services/matching/__init__.py` to export all matching components:

```python
from app.services.matching.signals import score_client_name, score_reference_numbers
from app.services.matching.explainability import ExplainabilityBuilder
from app.services.matching.thresholds import ThresholdManager
from app.services.matching.strategies import (
    MatchingStrategy,
    ExactMatchStrategy,
    FuzzyMatchStrategy,
    CombinedStrategy,
    StrategyResult,
)

__all__ = [
    # Signal scorers
    "score_client_name",
    "score_reference_numbers",
    # Explainability
    "ExplainabilityBuilder",
    # Threshold management
    "ThresholdManager",
    # Strategies
    "MatchingStrategy",
    "ExactMatchStrategy",
    "FuzzyMatchStrategy",
    "CombinedStrategy",
    "StrategyResult",
]
```
  </action>
  <verify>python -c "from app.services.matching import ThresholdManager, CombinedStrategy, ExplainabilityBuilder; print('OK')"</verify>
  <done>All matching components accessible from app.services.matching package</done>
</task>

</tasks>

<verification>
1. All imports work: `from app.services.matching import ThresholdManager, CombinedStrategy, ExplainabilityBuilder`
2. ThresholdManager has get_threshold, get_weights, get_min_match, get_gap_threshold methods
3. CombinedStrategy.evaluate() returns StrategyResult with score, component_scores, signal_details
4. Package __init__.py exports all 9 components
</verification>

<success_criteria>
- ThresholdManager queries MatchingThreshold table with category fallback
- ExactMatchStrategy returns 1.0 only on exact match of both signals
- FuzzyMatchStrategy uses signal scorers with weighted average
- CombinedStrategy tries exact first, falls back to fuzzy
- All strategies enforce CONTEXT.MD "both signals required" rule
</success_criteria>

<output>
After completion, create `.planning/phases/06-matching-engine-reconstruction/06-03-SUMMARY.md`
</output>
